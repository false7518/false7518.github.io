[{"title":"如何在iOS中播放，录制和编辑视频","date":"2017-04-19T08:52:23.000Z","path":"/uncategorized/如何在iOS中播放，录制和编辑视频.html","text":"录制视频，编辑并播放在日常生活中是一个很常用的功能。但是令人惊讶的是，这方面的技术帖子，文章并不好找。这个可能是因为学习iOS中录制和编辑的技术 — AVFoundation — 是非常困难的。本文，就简单讲述下，在iOS中如何进行视频的录制，播放，编辑。 在本文中，我们将为您提供AVFoundation API的实践经验，以便您可以在自己的应用程序中开始使用它们。您将学习如何： 从媒体库中选择并播放视频 录制视频并将视频保存到媒体库 将多个视频合并成一个组合的视频，并添加自定义背景音乐 入门让我们开始创建一个简单的应用程序，让您播放和录制视频并将其保存到文件中。 启动Xcode并使用iOS \\ Application \\ Single View Application模板创建一个新项目。为项目名称输入“VideoPlayRecord”，为设备系列选择iPhone，确保选中“使用故事板”和“使用自动参考计数”选项，并将项目保存到您选择的位置。 接下来，为您的项目添加一些必要的框架。 在左侧栏的“项目导航器”窗格中选择项目的根，以在中央窗格中显示项目信息。如果未选择项目目标，请选择它，然后切换到“构建阶段”选项卡。 现在点击“使用库链接二进制”部分的三角形来展开它。在这里，您可以向项目添加其他库/框架。 单击（+）按钮添加框架。您可以通过命令单击每个项目来选择打开的对话框中的多个项目。将以下框架添加到您的项目中： 资产图书馆 AVFoundation CoreMedia 媒体播放器 MobileCoreServies QuartzCore 在这个项目中，您将创建一个包含四个屏幕的应用程序。第一个将只有三个按钮，将允许您导航到以下三个屏幕： 视频播放 视频记录 视频合并 得到你的故事直在主窗口中选择MainStoryboard.storyboard以查看视图控制器。您需要将此视图控制器嵌入到导航控制器中，因为应用中将有多个屏幕。 要做到这一点，首先单击视图控制器给它焦点，然后从菜单中单击选择编辑器\\嵌入\\导航控制器。视图控制器现在与导航控制器相隔。 现在，从对象库中拖动三个UIButtons（右侧边栏的下半部分 - 如果对象库未被选中，则是第三个选项卡）到视图控制器。一旦您将其放在视图中，您可以按照以下方式设置按钮的标题： 选择和播放视频 录制和保存视频 合并视频 您可以通过点击按钮来选择每个按钮来设置标题，然后在属性检查器中编辑按钮的标题属性，这是右侧栏的上半部分的第四个选项卡。 接下来，为通过这些按钮显示的视图设置三个视图控制器。通过使用iOS \\ Cocoa Touch \\ UIViewController子类模板创建三个UIViewController子类对象来执行此操作。命名新类PlayVideoViewController，RecordVideoViewController和MergeVideoViewController。当您使用故事板时，请确保您取消选中“为每个类使用XIB用户界面”选项。 现在切换回MainStoryboard.storyboard并将三个UIViewControllers从对象库拖到你的故事板上。依次选择每个视图控制器对象，并切换到身份检查器（右侧栏的上半部分的第三个选项卡），以按如下方式为每个视图控制器设置类： PlayVideoViewController RecordVideoViewController MergeVideoViewController 现在你必须将所有这些东西挂在一起。您将通过创建一个从每个按钮切换到要加载的新视图控制器来执行此操作。 依次选择每个按钮，确保“连接检查器”（右侧栏的上半部分的第六个选项卡）已打开，并从“推送”连接器拖到相关视图控制器。 完成后，您的故事板应该类似于下面的屏幕： 很好，你已经设置了基本的UI！构建应用程序并运行它，以确保三个按钮按预期工作，每个按钮都进入辅助屏幕。 如果你对故事板和如何设置它们感到困惑，别担心！有一个教程。查看iOS 5教程系列中的开始故事板。 现在，您的UI正在运行，现在是创建这些辅助屏幕并给出一些实质内容的时候了！ 选择和播放视频导入头文件 12#import &lt;MobileCoreServices / UTCoreTypes.h&gt; #import &lt;MediaPlayer / MediaPlayer.h&gt; 添加代理协议，将以下代码添加到#import语句下方的@interface行的末尾： 1&lt;UIImagePickerControllerDelegate，UINavigationControllerDelegate&gt; 这将设置PlayVideoViewController作为UIImagePickerController和UINavigationController的委托，以便您可以在您的类中使用UIImagePickerController。具体来说，您将使用它来浏览照片库中的视频。 苹果提供的这个UIImagePickerController类是什么？它提供了一个基本的，可定制的用户界面，用于拍摄和录制电影。它还为新捕获的媒体提供了一些简单的编辑功能。如果您不需要完全定制的UI，通常最好使用图像选择器控制器从媒体库中选择音频和视频文件。要浏览媒体，您需要打开一个UIImagePickerController的实例作为弹出视图。 1234567891011121314151617181920//打开UIImagePickerController - （BOOL ） startMediaBrowserFromViewController ：（ UIViewController * ） controller usingDelegate ：（id ） delegate &#123; // 1 - 验证 if （（[ UIImagePickerController isSourceTypeAvailable ： UIImagePickerControllerSourceTypeSavedPhotosAlbum ] == NO ） || （ delegate == nil ） || （ controller == nil ）） &#123; return NO ; &#125; // 2 - 获取图像选择器 UIImagePickerController * mediaUI = [ [ UIImagePickerController alloc ] init ] ; mediaUI.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum; mediaUI.mediaTypes = [ [ NSArray alloc ] initWithObjects ： （NSString * ） kUTTypeMovie，nil ] ; //隐藏用于移动和缩放图片的控件，或 //修剪动画。要显示控件，请使用YES。 mediaUI.allowsEditing = YES ; mediaUI.delegate = delegate; // 3 - 显示图像选择器 [ controller presentModalViewController ： mediaUI animated ：YES ] ; 返回 YES ;&#125; 在上述代码中，您将执行以下操作： 1、检查UIImagePickerControllerSourceTypeSavedPhotosAlbum（定义的源）是否在设备上可用。当您使用UIImagePickerController来挑选媒体时，此检查是必不可少的。如果您不这样做，您可能会尝试从不存在的媒体库中挑选媒体，导致崩溃或其他意外问题。 2、如果您想要的源可用，则创建一个新的UIImagePickerController对象并设置其源和媒体类型。只有“kUTTypeMovie”包含在mediaTypes数组中，因为您只需要视频。您可以在数组中包含“kUTTypeImage”来选择图像。 3、最后，您将UIImagePickerController呈现为模态视图控制器。 如果您的媒体库中有视频，则您可以在第一个屏幕上点击“选择和播放视频”按钮，然后点击第二个“播放视频”按钮，看到它们与以下屏幕截图相似。屏幕。 注意：如果您在模拟器上运行此项目，则无法捕获视频。此外，您需要找出一种手动将视频添加到媒体库的方法。换句话说，我建议你在设备上测试这个项目！ 看到视频列表后，选择一个。您将被带到另一个显示视频的屏幕。点击“选择”按钮在这里实际选择视频。 如果您点击“选择”，除了应用程序返回播放视频屏幕外没有任何反应！这是因为您没有实现任何委托方法来处理在显示图像选择器时执行的操作。 UIImagePickerController有一个委托回调方法，可以在选择媒体时执行。实现通过添加以下代码的结束该方法PlayVideoViewController.m： 1234567891011121314151617- （void ） imagePickerController ：（ UIImagePickerController * ） picker didFinishPickingMediaWithInfo ：（NSDictionary * ） info &#123; // 1 - 获取媒体类型 NSString * mediaType = [ info objectForKey ： UIImagePickerControllerMediaType ] ; // 2 - 关闭图像选择器 [ self dismissModalViewControllerAnimated ：NO ] ; //处理电影捕获 如果 （ CFStringCompare （（ __bridge_retained CFStringRef ） mediaType的，kUTTypeMovie，0 ） == kCFCompareEqualTo ） &#123; // 3 -播放视频 MPMoviePlayerViewController * theMovie = [ [ MPMoviePlayerViewController的alloc ] initWithContentURL ：[信息objectForKey ： UIImagePickerControllerMediaURL ] ] ; [自presentMoviePlayerViewControllerAnimated ： theMovie ] ; // 4 -注册为再现完毕通知 [ [ NSNotificationCenter defaultCenter ]的addObserver ：自选择器：@selector （ myMovieFinishedCallback ：） 名称： MPMoviePlayerPlaybackDidFinishNotification对象： theMovie ] ; &#125; &#125; @selector （ myMovieFinishedCallback ：）名称： MPMoviePlayerPlaybackDidFinishNotification对象： theMovie ] ; &#125; &#125; @selector （ myMovieFinishedCallback ：）名称： MPMoviePlayerPlaybackDidFinishNotification对象： theMovie ] ; &#125; &#125; 上述代码执行以下操作： 获取媒体类型，以便稍后验证所选媒体是视频。 关闭图像选择器，使其不再显示在屏幕上。 验证所选媒体是否为视频，然后创建MPMoviePlayerViewController的实例来播放。 添加一个回调方法，该方法将在电影完成播放后执行。 所述myMovieFinishedCallback：在步骤＃4中引用的方法需要实现。下面的代码添加到年底PlayVideoViewController.m： 1234567//电影完成后，释放控制器。- （void ） myMovieFinishedCallback ：（NSNotification * ） aNotification &#123; [ self dismissMoviePlayerViewControllerAnimated ] ; 的MPMoviePlayerController * theMovie = [ aNotification对象] ; [ [ NSNotificationCenter defaultCenter ] removeObserver ： self 名： MPMoviePlayerPlaybackDidFinishNotification对象： theMovie ] ;&#125; 最后一件事是为用户点击“取消”而不是选择视频添加一个处理程序。在ImagePickerController下面添加以下代码：didFinishPickingMediaWithInfo： 1234//为了响应用户点击取消。- （void ） imagePickerControllerDidCancel ：（ UIImagePickerController * ） picker &#123; [ self dismissModalViewControllerAnimated ： YES ] ;&#125; 如果用户取消操作，图像选择器将被取消。 编译并运行您的项目。按“选择和播放视频”按钮，然后按“播放视频”按钮，最后从列表中选择一个视频。您应该可以看到在媒体播放器播放的视频。 录制和保存视频现在，您有视频播放功能，现在是使用设备的相机录制视频并将其保存到媒体库的时候了。切换回故事板，并执行以下操作： 添加一个名为“录制视频”的新按钮到录像视频控制器。 如前所述，切换到助手编辑器模式，并将“录制视频”按钮连接到名为recordAndPlay的操作：。 获取编码的时间！用以下内容替换RecordVideoViewController.h的内容： 123456789101112#import &lt;MediaPlayer / MediaPlayer.h&gt; #import &lt;MobileCoreServices / UTCoreTypes.h&gt; #import &lt;AssetsLibrary / AssetsLibrary.h&gt; @interface RecordVideoViewController ： UIViewController - （ IBAction ） recordAndPlay ：（id ） sender;- （BOOL ） startCameraControllerFromViewController ：（ UIViewController * ）控制器 usingDelegate ：（id ） delegate;- （void ） video : (（NSString * ） videoPath didFinishSavingWithError ：（NSError * ） error contextInfo ：（void * ） contextInfo; @结束 您可能已经注意到：其中一些与您在PlayVideoViewController中所做的相似。至于没有的位： AssetsLibrary.h导入可以访问照片应用程序控件下的视频和照片。当您将视频保存到已保存的照片库时，您需要访问AssetsLibrary框架。 资产库包括已保存的照片相册中的媒体，来自iTunes的媒体以及直接导入设备的媒体。您可以使用AssetsLibrary检索所有资产组的列表，并将图像和视频保存到已保存的照片相册中。 其他新产品视频：didFinishSavingWithError：contextInfo： 。顾名思义，该方法在将视频保存到资产/照片库后执行。 切换到RecordVideoViewController.m并将以下内容添加到recordAndPlay：： 1[ self startCameraControllerFromViewController ： self usingDelegate ： self ] ; 你再次在熟悉的地区。该代码简单地调用startCameraControllerFromViewController：usingDelegate：当“录制视频”按钮被点击时。当然，这意味着你应该添加下一个方法的实现。将以下代码添加到文件的末尾（但在最后的@end之前）： 123456789101112131415161718192021- （BOOL ） startCameraControllerFromViewController ：（ UIViewController * ）控制器 usingDelegate ：（id ） delegate &#123; // 1 - Validatt if if （（[ UIImagePickerController isSourceTypeAvailable ： UIImagePickerControllerSourceTypeCamera ] == NO ） || （ delegate == nil ） || （ controller == nil ）） &#123; return NO ; &#125; // 2 - 获取图像选择器 UIImagePickerController * cameraUI = [ [ UIImagePickerController alloc ] init ] ; cameraUI.sourceType = UIImagePickerControllerSourceTypeCamera; //显示允许用户选择影片捕获的 控件cameraUI.mediaTypes = [ [ NSArray alloc ] initWithObjects ：（NSString * ） kUTTypeMovie，nil ] ; //隐藏用于移动和缩放图片的控件，或 //修剪动画。要显示控件，请使用YES。 cameraUI.allowsEditing = NO ; cameraUI.delegate = delegate; // 3 - 显示图像选择器 [ controller presentModalViewController ： cameraUI animated ： YES ] ; 返回 YES ;&#125; 在上面的代码中，您检查“UIImagePickerControllerSourceTypeCamera”而不是“UIImagePickerControllerSourceTypeSavedPhotosAlbum”，因为您要使用相机。其余的代码与以前使用的代码大致相同。 构建并运行你的代码，看看你到目前为止。 转到记录屏幕，然后按“录制视频”按钮。相机界面打开，而不是照片库。通过点击屏幕底部的红色记录按钮开始录制视频，完成录制后再次点击。 这个视频看起来更令人兴奋。我不能在这里张贴，但是有一个很好的宝贝就在屏幕外！只是开玩笑，但是当您看到自己的设备运行时更令人兴奋。：] 当您进入下一个屏幕时，您可以选择使用录制的视频或重新拍摄视频。如果您选择“使用”，您会注意到没有任何反应 - 这是因为您猜测到，没有实现回调方法。您需要回调方法将录制的视频保存到媒体库。 为了实现回调方法，下面的代码添加到年底RecordVideoViewController.m： 1234567891011121314151617181920- （void ） imagePickerController ：（ UIImagePickerController * ） picker didFinishPickingMediaWithInfo ：（NSDictionary * ） info &#123; NSString * mediaType = [ info objectForKey ： UIImagePickerControllerMediaType ] ; [ self dismissModalViewControllerAnimated ：NO ] ; //处理电影捕获 if （ CFStringCompare （（ __bridge_retained CFStringRef ） mediaType，kUTTypeMovie，0 ） == kCFCompareEqualTo ） &#123; NSString * moviePath = [ [ info objectForKey ： UIImagePickerControllerMediaURL ] path ] ; 如果 （ UIVideoAtPathIsCompatibleWithSavedPhotosAlbum （ moviePath ）） &#123; UISaveVideoAtPathToSavedPhotosAlbum （ moviePath，自我， @selector （视频： didFinishSavingWithError ： contextInfo ：），零） ; nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; &#125; else &#123; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Video Saved”消息：@ “保存到相册” 委托： self cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; &#125; &#125; 在上面的代码中，imagePickerController：didFinishPickingMediaWithInfo：给你一个moviePath。您验证电影可以保存到设备的相册，如果是这样保存。 UISaveVideoAtPathToSavedPhotosAlbum是SDK提供的将视频保存到照片相册的默认方式。作为参数，你通过这两个被保存到该视频的路径，以及一个回调方法，将通知您的保存操作的状态。 构建代码并运行它。录制视频并选择“使用”。如果弹出“视频保存”按钮，则您的视频已成功保存到照片库。 AVFoundation简介现在，您的视频播放和录制已启动并运行，让我们进一步复杂一点：AVFoundation。 自iOS 4.0以来，iOS SDK在AVFoundation框架中提供了许多视频编辑API。使用这些API，您可以将任何种类的CGAffineTransform应用于视频，并将多个视频和音频文件合并到一个视频中。 本教程的最后几节将引导您将两个视频合并为单个视频并添加背景音轨。 在进入代码之前，先来讨论一些理论。 AVAsset这是一个抽象类，表示定时的视听媒体，如视频和音频。每个资产包含旨在一起呈现或处理的每个轨道的集合，每个轨道均包含但不限于音频，视频，文本，隐藏字幕和字幕。 AVAsset对象定义构成资产的轨道的集合属性。轨道由AVAssetTrack的实例表示。 在典型的简单情况下，一个轨道表示音频分量，另一个表示视频分量; 在复杂的组合中，可能存在多个重叠的音频和视频轨道。您将代表要合并为AVAsset对象的视频和音频文件。 AVCompositionAVComposition对象以自定义的时间排列方式组合来自多个基于文件的源的媒体数据，以便一起呈现或处理它们。无论容器类型如何，所有基于文件的视听资产均可合并。 在其顶层，AVComposition是一个轨道的集合，每个轨道根据时间线呈现特定类型的媒体，如音频或视频。每个曲目由AVCompositionTrack的一个实例表示。 AVMutableComposition和AVMutableCompositionTrackAVMutableComposition和AVMutableCompositionTrack也提供了构建组合的高级界面。这些对象提供插入，移除和缩放操作，而无需直接操纵组合轨道的轨道段数组。 AVMutableComposition和AVMutableCompositionTrack使用更高级的结构，如AVAsset和AVAssetTrack。这意味着客户端可以使用与创建的候选来源相同的引用，以便在包含在组合中之前对其进行检查或预览。 简而言之，您有一个AVMutableComposition，您可以向其添加多个AVMutableCompositionTrack实例。每个AVMutableCompositionTrack将有一个单独的媒体资源。 和休息为了将CGAffineTransform应用于曲目，您将使用AVVideoCompositionInstruction和AVVideoComposition。AVVideoCompositionInstruction对象表示由合成器执行的操作。该对象包含多个AVMutableVideoCompositionLayerInstruction对象。 您使用AVVideoCompositionLayerInstruction对象来修改变换和不透明度斜坡以应用于AV组合中的给定轨迹。AVMutableVideoCompositionLayerInstruction是AVVideoCompositionLayerInstruction的可变子类。 AVVideoComposition对象维护一组指令来执行其组合，并且AVMutableVideoComposition对象表示可变视频构图。 结论 您有一个主AVMutableComposition对象包含多个AVMutableCompositionTrack实例。每条轨道代表资产。 您有AVMutableVideoComposition对象包含多个AVMutableVideoCompositionInstructions。 每个AVMutableVideoCompositionInstruction包含多个AVMutableVideoCompositionLayerInstruction实例。 每层指令用于将特定的变换应用于给定的轨道。 知道了吗 在您下载项目示例代码之前，最终将进行测试。;] 现在你至少听说过你将用来合并媒体的所有主要对象。这可能有点混乱，但是当你编写一些代码时，事情会变得更加清晰。我承诺！ 合并视频现在把这个理论用了！打开MainStoryboard.storyboard并选择Merge Video View Controller。将四个按钮添加到屏幕，并将其命名如下： 负载资产1 负载资产2 加载音频 合并和保存视频 切换到助手编辑器模式，并将您的四个按钮连接到以下操作： loadAssetOne： loadAssetTwo： loadAudio： mergeAndSave： 最后的结果应该是这样的： 现在切换到MergeVideoViewController.h并将其内容替换为： 1234567891011121314151617181920212223#import &lt;AVFoundation / AVFoundation.h&gt; #import &lt;CoreMedia / CoreMedia.h&gt; #import &lt;MobileCoreServices / UTCoreTypes.h&gt; #import &lt;AssetsLibrary / AssetsLibrary.h&gt; #import &lt;MediaPlayer / MediaPlayer.h&gt; @interface MergeVideoViewController ： UIViewController &#123; BOOL isSelectingAssetOne;&#125; @property （ nonatomic，strong ） AVAsset * firstAsset;@property （ nonatomic，strong ） AVAsset * secondAsset;@property （ nonatomic，strong ） AVAsset * audioAsset;@property （弱，非原子） IBOutlet UIActivityIndi​​catorView * activityView; - （ IBAction ） loadAssetOne ：（id ） sender;- （ IBAction ） loadAssetTwo ：（id ） sender;- （ IBAction ） loadAudio ：（id ） sender;- （ IBAction ） mergeAndSave ：（id ） sender;- （BOOL ） startMediaBrowserFromViewController ：（ UIViewController * ） controller usingDelegate ：（id ）代表;- （void ） exportDidFinish ：（ AVAssetExportSession * ） session; @结束 以上大部分应该是熟悉的。有几个新的属性，但它们主要是保留对您添加的资产的引用，以创建最终合并的视频。除了资产之外，还有一个活动指标，当应用程序合并文件时会显示，因为可能需要一些时间来完成该过程。 要合成上面添加的属性，请切换到MergeVideoViewController.m，并在文件顶部添加以下内容，位于@implementation行之下： 12@synthesize firstAsset，secondAsset，audioAsset;@synthesize activityView; 然后，将以下内容添加到loadAssetOne中： 12345678if （[ UIImagePickerController isSourceTypeAvailable ： UIImagePickerControllerSourceTypeSavedPhotosAlbum ] == NO ） &#123; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Error” message ：@ “No saved Album Found” delegate ：nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; &#125; else &#123; isSelectingAssetOne = TRUE; [ self startMediaBrowserFromViewController ： self usingDelegate ： self ] ; &#125; 将此代码添加到loadAssetTwo中： 12345678if （[ UIImagePickerController isSourceTypeAvailable ： UIImagePickerControllerSourceTypeSavedPhotosAlbum ] == NO ） &#123; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Error” message ：@ “No saved Album Found” delegate ：nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ;&#125; else &#123; isSelectingAssetOne = FALSE; [ self startMediaBrowserFromViewController ： self usingDelegate ： self ] ; &#125; 请注意，除了分配给isSelectingAssetOne的值之外，上述两个实例中的代码几乎相同。您可以使用UIImagePickerController来像“播放视频”部分一样选择视频文件。所述isSelectingAssetOne变量用来识别哪个资产当前选择。 将以下代码添加到UIImagePickerController显示和处理文件的末尾： 1234567891011121314151617181920212223242526272829303132333435363738394041- （BOOL ） startMediaBrowserFromViewController ：（ UIViewController * ） controller usingDelegate ：（id ） delegate &#123; // 1 - 验证 if （（[ UIImagePickerController isSourceTypeAvailable ： UIImagePickerControllerSourceTypeSavedPhotosAlbum ] == NO ） || （ delegate == nil ） || （ controller == nil ）） &#123; return NO ; &#125; // 2 - 创建图像选择器 UIImagePickerController * mediaUI = [ [ UIImagePickerController alloc ] init ] ; mediaUI.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum; mediaUI.mediaTypes = [ [ NSArray alloc ] initWithObjects ：（NSString * ） kUTTypeMovie，nil ] ; //隐藏用于移动和缩放图片的控件，或 //修剪动画。要显示控件，请使用YES。 mediaUI.allowsEditing = YES ; mediaUI.delegate = delegate; // 3 - 显示图像选择器 [ controller presentModalViewController ： mediaUI animated ： YES ] ; 返回 YES ;&#125; - （void ） imagePickerController ：（ UIImagePickerController * ） picker didFinishPickingMediaWithInfo ：（NSDictionary * ） info &#123; // 1 - 获取媒体类型 NSString * mediaType = [ info objectForKey ： UIImagePickerControllerMediaType ] ; // 2 - 关闭图像选择器 [ self dismissModalViewControllerAnimated ：NO ] ; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Asset Loaded”消息：@ “Video One Loaded” 委托：nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; firstAsset = [ AVAsset assetWithURL ：[ info objectForKey ： UIImagePickerControllerMediaURL ] ] ; &#125; else &#123; NSLog （@ “Video two Loaded” ） ; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Asset Loaded”消息：@ “Video Two Loaded” 委托：nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; secondAsset = [ AVAsset assetWithURL ：[ info objectForKey ： UIImagePickerControllerMediaURL ] ] ; &#125; &#125; &#125; 请注意，在imagePickerController：didFinishPickingMediaWithInfo：中，您可以使用图像选择器返回的媒体URL来初始化每个资产变量。还要注意，如何使用isSelectingAssetOne变量来确定设置了哪个资产变量。 此时，您有代码可以选择两个视频资源。 编译并运行，并确保您的库中至少有两个视频。然后选择“合并视频”选项，然后选择两个视频。如果一切正常，您都可以在选择每个视频后看到“已加载资产”消息。 下一步是添加功能来选择音频文件。 UIImagePickerController仅提供从媒体库中选择视频和图像的功能。要从音乐库中选择音频文件，您将使用MPMediaPickerController。它的工作原理与UIImagePickerController完全相同，但不是图像和视频，它会访问媒体库中的音频文件。 将以下代码添加到loadAudio中： 1234MPMediaPickerController * mediaPicker = [ [ MPMediaPickerController alloc ] initWithMediaTypes ： MPMediaTypeAny ] ;mediaPicker.delegate = self;mediaPicker.prompt = @ “选择音频” ;[ self presentModalViewController ： mediaPicker animated ：YES ] ; 上述代码创建一个新的MPMediaPickerController实例，并将其显示为模态视图控制器。 建立并运行。现在，当您点击“加载音频”按钮时，您可以访问设备上的音频库。（当然，您需要在设备上安装一些音频文件，否则列表将为空。） 如果您从列表中选择一首歌曲，您会发现没有任何反应。没错，MPMediaPickerController需要委托方法！在文件末尾添加以下两种方法： 1234567891011121314151617- （无效） mediaPicker ：（ MPMediaPickerController * ） mediaPicker didPickMediaItems ：（ MPMediaItemCollection * ） mediaItemCollection &#123; 的NSArray * selectedSong = [ mediaItemCollection项] ; if （[ selectedSong count ] &gt; 0 ） &#123; MPMediaItem * songItem = [ selectedSong objectAtIndex ：0 ] ; audioAsset = [ AVAsset assetWithURL ： songURL ] ; NSLog （@ “Audio Loaded” ） ; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Asset Loaded”消息：@ “Audio Loaded” 委托：nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; &#125; [ self dismissModalViewControllerAnimated ：YES ] ;&#125; - （void ） mediaPickerDidCancel ：（ MPMediaPickerController * ） mediaPicker &#123; [ self dismissModalViewControllerAnimated ： YES ] ;&#125; 代码非常类似于UIImagePickerController的委托方法。您可以根据通过MPMediaPickerController选择的媒体项来设置音频资源。 建立并再次运行。转到合并视频屏幕并选择音频文件。如果没有错误，您应该看到“加载音频”消息。 您现在可以正确加载所有视频和音频资源。现在是时候将各种媒体文件合并成一个文件了。 但是在你进入该代码之前，你必须做一点设置。将以下代码添加到mergeAndSave：： 123456789101112131415161718192021222324252627282930313233343536if （ firstAsset ！= nil &amp;&amp; secondAsset ！= nil ） &#123; [ activityView startAnimating ] ; // 1 - 创建AVMutableComposition对象。此对象将保存您的AVMutableCompositionTrack实例。 AVMutableComposition * mixComposition = [ [ AVMutableComposition alloc ] init ] ; // 2 - 视频轨道 AVMutableCompositionTrack * firstTrack = [ mixComposition addMutableTrackWithMediaType ： AVMediaTypeVideo preferredTrackID ： kCMPersistentTrackID_Invalid ] ; [ firstTrack insertTimeRange ： CMTimeRangeMake （ kCMTimeZero，firstAsset.duration ） ofTrack ：[ [ firstAsset tracksWithMediaType ： AVMediaTypeVideo ] objectAtIndex ：0 ] atTime ： kCMTimeZero误差：零] ; [ firstTrack insertTimeRange ： CMTimeRangeMake （ kCMTimeZero，secondAsset.duration ） ofTrack ：[ [ secondAsset tracksWithMediaType ： AVMediaTypeVideo ] objectAtIndex ：0 ] atTime ： firstAsset.duration error ：nil ] ; // 3 - 音频轨道 if （ audioAsset ！= nil ）&#123; AVMutableCompositionTrack * AudioTrack = [ mixComposition addMutableTrackWithMediaType ： AVMediaTypeAudio 0 ] atTime ： firstAsset.duration error ：nil ] ; // 3 - 音频轨道if （ audioAsset ！= nil ）&#123; AVMutableCompositionTrack * AudioTrack = [ mixComposition addMutableTrackWithMediaType ： AVMediaTypeAudio 0 ] atTime ： firstAsset.duration error ：nil ] ; // 3 - 音频轨道if （ audioAsset ！= nil ）&#123; AVMutableCompositionTrack * AudioTrack = [ mixComposition addMutableTrackWithMediaType ： AVMediaTypeAudio preferredTrackID ： kCMPersistentTrackID_Invalid ] ; [ AudioTrack insertTimeRange ： CMTimeRangeMake （ kCMTimeZero，CMTimeAdd （ firstAsset.duration，secondAsset.duration ）） ofTrack ：[ [ audioAsset tracksWithMediaType ： AVMediaTypeAudio ] objectAtIndex ：0 ] atTime ： kCMTimeZero误差：零] ; &#125; // 4 - 获取路径 NSArray * paths = NSSearchPathForDirectoriesInDomains （ NSDocumentDirectory，NSUserDomainMask，YES ） ; NSString * documentsDirectory = [ paths objectAtIndex ：0 ] ; NSString * myPathDocs = [ documentsDirectory stringByAppendingPathComponent ： [ NSString stringWithFormat ：@ “mergeVideo-％d.mov”，arc4random （） ％ 1000 ] ] ; NSURL * url = [ NSURL fileURLWithPath ： myPathDocs ] ; // 5 - 创建导出器 AVAssetExportSession * exporter = [ [ AVAssetExportSession alloc ] initWithAsset ： mixComposition presetName ： AVAssetExportPresetHighestQuality ] ; exporter.outputURL = url; exporter.outputFileType = AVFileTypeQuickTimeMovie; exporter.shouldOptimizeForNetworkUse = YES ; [ exporter exportAsynchronouslyWithCompletionHandler ：^ &#123; dispatch_async （ dispatch_get_main_queue （），^ &#123; [ self exportDidFinish ： exporter ] ; &#125; ） ; &#125; ] ; &#125; 以下是上述代码的分步细分： 您创建一个AVMutableComposition对象来保存视频和音轨以及变换效果。 接下来，您将为视频创建AVMutableCompositionTrack，并将其添加到AVMutableComposition对象。然后将两个视频插入到新创建的AVMutableCompositionTrack中。 请注意，insertTimeRange方法允许您将视频的一部分插入主要合成而不是整个视频。这样，您可以将视频剪辑到您所选择的时间范围。 在这种情况下，您要插入整个视频，因此您可以创建一个从kCMTimeZero到您的视频资源持续时间的时间范围。atTime参数允许您将您的视频/音轨放在您想要的组合中。注意如何firstAsset被插入在时间零点，和secondAsset被插入在所述第一视频的结尾。本教程假设您希望您的视频资产一个接一个。但是您也可以通过玩时间范围来重叠资产。 对于使用时间范围，您可以使用CMTime结构体。CMTime结构是表示时间的非透明可变结构体，其中时间可以是时间戳或持续时间。 同样，您为音频创建一个新曲目[AVMutableCompositionTrack？]，并将其添加到主要作品中。这次您将音频时间范围设置为第一和第二个视频的持续时间的总和，因为这将是视频的完整长度。 在保存最终视频之前，您需要保存文件的路径。因此，创建一个随机文件名，指向文档文件夹中的文件。 最后，渲染和导出合并的视频。为此，您将创建一个AVAssetExportSession对象，该对象对AVAsset源对象的内容进行转码，以创建由指定的导出预设描述的窗体的输出。 在使用包含源介质的资产，导出预设名称（presetName）和输出文件类型（outputFileType）初始化导出会话后，通过调用exportAsynchronouslyWithCompletionHandler：启动导出。 因为导出是异步执行的，所以该方法立即返回。exportAsynchronouslyWithCompletionHandler提供的完成处理程序：是否导出失败，完成或被取消。完成后，出口商的状态属性表示出口是否成功完成。如果失败，导出器的错误属性的值提供有关失败原因的其他信息。 请注意，完成处理程序调用exportDidFinish：一个需要实现的方法。将以下代码添加到文件末尾： 12345678910111213141516171819202122232425- （void ） exportDidFinish ：（ AVAssetExportSession * ） session &#123; if （ session.status == AVAssetExportSessionStatusCompleted ） &#123; NSURL * outputURL = session.outputURL; ALAssetsLibrary * library = [ [ ALAssetsLibrary alloc ] init ] ; 如果 （[库videoAtPathIsCompatibleWithSavedPhotosAlbum ： outputURL ] ） &#123; [库writeVideoAtPathToSavedPhotosAlbum ： outputURL completionBlock ：^ （NSURL * assetURL，NSError *错误）&#123; dispatch_async （ dispatch_get_main_queue （），^ &#123; if （ error ） &#123; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Error” message ：@ “Video Saving Failed” 委托：nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; &#125; else &#123; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Video Saved”消息：@ “保存到相册” 委托： self cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; &#125; &#125; ） ; &#125; ] ; &#125; &#125; audioAsset = nil ; firstAsset = nil ; secondAsset = nil ; [ activityView stopAnimating ] ;&#125; 导出成功完成后，新导出的视频将保存到相册中。您实际上不需要做 - 您可以使用AssetBrowser浏览到您保存到文档文件夹的最终视频。但是，将输出视频复制到相册更容易，以便您可以看到最终的输出。 继续，建立并运行您的项目！ 选择视频和音频文件并合并选定的文件。如果合并成功，您应该看到一个“视频保存”消息。此时，您的新视频应该存在于相册中。 转到相册，或使用自己的“选择和播放视频”屏幕浏览！您会注意到，虽然视频已经合并，但有一些方向问题。肖像视频处于横向模式，有时视频会颠倒。 这是由于默认的AVAsset方向。使用默认iPhone摄像头应用程序录制的所有影片和影像文件都将视频帧设置为横向，因此媒体将以横向模式保存。 AVAsset有一个preferredTransform属性，其中包含媒体方向信息，每当您使用照片应用程序或QuickTime查看媒体文件时，它将应用于媒体文件。在上面的代码中，您尚未对AVAsset对象应用转换，因此导向问题。 您可以通过将必要的转换应用到您的AVAsset对象来轻松更正。但是，由于您的两个视频文件具有不同的方向，因此您需要使用两个独立的AVMutableCompositionTrack实例，而不是像您最初一样。 将mergeAndSave中的第2个部分替换为以下，以便您有两个AVMutableCompositionTrack实例而不是一个： 123456789// 2 - 创建两个视频轨道 AVMutableCompositionTrack * firstTrack = [ mixComposition addMutableTrackWithMediaType ： AVMediaTypeVideo preferredTrackID ： kCMPersistentTrackID_Invalid ] ;[ firstTrack insertTimeRange ： CMTimeRangeMake （ kCMTimeZero，firstAsset.duration ） ofTrack ：[ [ firstAsset tracksWithMediaType ： AVMediaTypeVideo ] objectAtIndex ：0 ] atTime ： kCMTimeZero误差：零] ;AVMutableCompositionTrack * secondTrack = [ mixComposition addMutableTrackWithMediaType ： AVMediaTypeVideo preferredTrackID ： kCMPersistentTrackID_Invalid ] ;[ secondTrack insertTimeRange ： CMTimeRangeMake （ kCMTimeZero，secondAsset.duration ） ofTrack ：[ [ secondAsset tracksWithMediaType ： AVMediaTypeVideo ] objectAtIndex ：0 ] atTime ： firstAsset.duration误差：零] ; 由于您现在有两个独立的AVMutableCompositionTrack实例，因此您需要将AVMutableVideoCompositionLayerInstruction应用于每个轨道，以便修复方向。所以在你刚刚替换的代码之后添加以下代码（在第3节之前）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 2.1 - 创建AVMutableVideoCompositionInstruction AVMutableVideoCompositionInstruction * mainInstruction = [ AVMutableVideoCompositionInstruction videoCompositionInstruction ] ;mainInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, CMTimeAdd(firstAsset.duration, secondAsset.duration));// 2.2 - Create an AVMutableVideoCompositionLayerInstruction for the first trackAVMutableVideoCompositionLayerInstruction *firstlayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:firstTrack];AVAssetTrack *firstAssetTrack = [[firstAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];UIImageOrientation firstAssetOrientation_ = UIImageOrientationUp;BOOL isFirstAssetPortrait_ = NO;CGAffineTransform firstTransform = firstAssetTrack.preferredTransform;if (firstTransform.a == 0 &amp;&amp; firstTransform.b == 1.0 &amp;&amp; firstTransform.c == -1.0 &amp;&amp; firstTransform.d == 0) &#123; firstAssetOrientation_ = UIImageOrientationRight; isFirstAssetPortrait_ = YES;&#125;if (firstTransform.a == 0 &amp;&amp; firstTransform.b == -1.0 &amp;&amp; firstTransform.c == 1.0 &amp;&amp; firstTransform.d == 0) &#123; firstAssetOrientation_ = UIImageOrientationLeft; isFirstAssetPortrait_ = YES;&#125;if (firstTransform.a == 1.0 &amp;&amp; firstTransform.b == 0 &amp;&amp; firstTransform.c == 0 &amp;&amp; firstTransform.d == 1.0) &#123; firstAssetOrientation_ = UIImageOrientationUp;&#125;if (firstTransform.a == -1.0 &amp;&amp; firstTransform.b == 0 &amp;&amp; firstTransform.c == 0 &amp;&amp; firstTransform.d == -1.0) &#123; firstAssetOrientation_ = UIImageOrientationDown;&#125;[firstlayerInstruction setTransform:firstAsset.preferredTransform atTime:kCMTimeZero];[firstlayerInstruction setOpacity:0.0 atTime:firstAsset.duration];// 2.3 - Create an AVMutableVideoCompositionLayerInstruction for the second trackAVMutableVideoCompositionLayerInstruction *secondlayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:secondTrack];AVAssetTrack *secondAssetTrack = [[secondAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];UIImageOrientation secondAssetOrientation_ = UIImageOrientationUp;BOOL isSecondAssetPortrait_ = NO;CGAffineTransform secondTransform = secondAssetTrack.preferredTransform;if (secondTransform.a == 0 &amp;&amp; secondTransform.b == 1.0 &amp;&amp; secondTransform.c == -1.0 &amp;&amp; secondTransform.d == 0) &#123; secondAssetOrientation_= UIImageOrientationRight; isSecondAssetPortrait_ = YES;&#125;if (secondTransform.a == 0 &amp;&amp; secondTransform.b == -1.0 &amp;&amp; secondTransform.c == 1.0 &amp;&amp; secondTransform.d == 0) &#123; secondAssetOrientation_ = UIImageOrientationLeft; isSecondAssetPortrait_ = YES;&#125;if (secondTransform.a == 1.0 &amp;&amp; secondTransform.b == 0 &amp;&amp; secondTransform.c == 0 &amp;&amp; secondTransform.d == 1.0) &#123; secondAssetOrientation_ = UIImageOrientationUp;&#125;if (secondTransform.a == -1.0 &amp;&amp; secondTransform.b == 0 &amp;&amp; secondTransform.c == 0 &amp;&amp; secondTransform.d == -1.0) &#123; secondAssetOrientation_ = UIImageOrientationDown;&#125;[secondlayerInstruction setTransform:secondAsset.preferredTransform atTime:firstAsset.duration];&#125; 在第2.1节中，您将创建一个AVMutableVideoCompositionInstruction对象，该对象将保存图层指令。 然后在第2.2节中，将方向固定添加到第一个轨道，如下所示： 您创建一个AVMutableVideoCompositionLayerInstruction并将其与您的firstTrack相关联。 接下来，您将从AVAsset创建一个AVAssetTrack对象。AVAssetTrack对象为所有资产提供轨道级检查界面。您需要此对象才能访问资产的preferredTransform和dimension。 然后，确定您的AVAsset的方向。这将在确定导出的视频大小时稍后使用。 接下来，应用preferredTransform来修复方向。 您还将firstAsset.duration的第一层的不透明度设置为零。这是因为您希望您的第一首曲目在完成播放后消失。否则，第一轨道的最后一帧将保持在屏幕上，并与来自第二轨道的视频重叠。 2.3节中的代码与＃2.2节中的代码几乎相同。这只是应用于第二轨道的方向固定。 接下来，在第2.3节之后添加以下代码（在第3节之前）： 123456789101112131415161718192021222324252627282930// 2.4 - 添加指令 mainInstruction.layerInstructions = [ NSArray arrayWithObjects ： firstlayerInstruction，secondlayerInstruction，nil ] ;AVMutableVideoComposition * mainCompositionInst = [ AVMutableVideoComposition videoComposition ] ;mainCompositionInst.instructions = [ NSArray arrayWithObject ： mainInstruction ] ;mainCompositionInst.frameDuration = CMTimeMake （1，30 ） ; CGSize naturalSizeFirst，naturalSizeSecond;if （ isFirstAssetPortrait_ ）&#123; naturalSizeFirst = CGSizeMake （ FirstAssetTrack.naturalSize.height，FirstAssetTrack.naturalSize.width ） ;&#125; else &#123; naturalSizeFirst = FirstAssetTrack.naturalSize;&#125; if （ isSecondAssetPortrait_ ）&#123; naturalSizeSecond = CGSizeMake （ SecondAssetTrack.naturalSize.height，SecondAssetTrack.naturalSize.width ） ;&#125; else &#123; naturalSizeSecond = SecondAssetTrack.naturalSize;&#125; float renderWidth，renderHeight;if （ naturalSizeFirst.width&gt; naturalSizeSecond.width ） &#123; renderWidth = naturalSizeFirst.width;&#125; else &#123; renderWidth = naturalSizeSecond.width;&#125; if （ naturalSizeFirst.height&gt; naturalSizeSecond.height ） &#123; renderHeight = naturalSizeFirst.height;&#125; else &#123; renderHeight = naturalSizeSecond.height;&#125; MainCompositionInst.renderSize = CGSizeMake （ renderWidth， 现在您有第一和第二个曲目的AVMutableVideoCompositionLayerInstruction实例，您只需将它们添加到主AVMutableVideoCompositionInstruction对象即可。接下来，将mainInstruction对象添加到AVMutableVideoComposition实例的instructions属性中。您还将组合的帧速率设置为30帧/秒。 那么你必须找到最终视频的导出大小。首先我们要检查资源是纵向还是横向。为此，我们从前面使用变量isFirstAssetPortrait和isSecondAssetPortrait。如果它们是风景，我们可以使用我们提供的naturalSize属性，但是如果它们是纵向的，我们必须翻转naturalSize，使得宽度现在是高度，反之亦然。我们将每个结果保存到变量中。 那么我们必须确定两个资产中哪一个是更广泛的，哪一个是较高的。这是为了确保导出的视频足够大以容纳所有的每个视频。通过一些简单的比较，我们将结果保存到变量中。 然后，您可以将导出的renderSize设置为找到的renderWidth和renderHeight。 现在，您已经配置了一个AVMutableVideoComposition对象，所有您需要做的是将其分配给您的导出器。在第5节中，在该部分的第4行之后插入以下代码（就在exportAsynchronouslyWithCompletionHandler： call 之前）： 1exporter.videoComposition = mainCompositionInst; 呃 - 就是这样！ 构建并运行您的项目。如果您通过组合两个视频（可选的音频文件）创建一个新的视频，您将看到当您播放新的合并的视频时，方向问题已经消失。","tags":[]},{"title":"个人简历","date":"2017-04-13T09:01:36.000Z","path":"/uncategorized/个人简历.html","text":"个人信息姓名：祁伟鹏&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生日：1992.09.20 学历：本科&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;专业： 计算机科学与技术 期望薪资：15000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工作经验：3年 学习经历 时间段 类型 学校 专业 2013.12~2014.06 培训 千峰教育 iOS应用开发 2010.09~2014.06 统招 集宁师范学院 计算机科学与技术 工作经历北京育学林教育技术有限公司工作时间：2016.5~ 职位：iOS开发工程师&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;薪资：18000 工作内容： 独立完成公司iOS产品开发维护 iOS产品需求分析 协同技术部负责人管理前端开发人员 北京沃安科技有限公司工作时间：2014.6~2016.3 职位：iOS开发工程师&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;薪资：13000 工作内容： 独立完成公司iOS产品的开发维护 iOS产品需求分析 项目简介京版云（已上线）应用链接 项目背景： 基于北京出版集团提供的资源，打造一个面向于教师家长学生的平台。包括资源的上传下载，分享查看，班级信息的管理。 开发部分： 所有功能。 功能点： 定位学生、班级信息管理、电子课本、语音跟读、多媒体消息发布、个人资源库管理、参加活动 直播客（已上线）应用链接 项目背景： 早期视频直播应用，14年一开发完毕，不断更新。公司自主开发视频服务器，对上传视频进行软硬解码，生成m3u8视频流。用户可以直播并将观看链接分享至微信，其他人就可通过分享出的链接看直播。直播因使用m3u8流有延迟0s~8s。 开发部分： 所有功能。 功能： 微信登录、视频直播、微信分享、视频管理 懂你心理（待上线）项目背景： 正在内测中，针对需要心理帮助的群体。 开发部分： 所有功能。 功能： 资讯、心理测评、用户群组 医带医路（已上线）应用链接 项目背景： 与北京301医院合作的医生转诊平台，因融资失败已不维护。 开发部分： 所有功能。 功能： 医生间咨询功能、医生视频直播功能、直播互动功能、打赏功能、病历档案、群聊 刷脸（已上线）项目背景： 该应用已下架，熟人借贷APP。 开发部分： 所有功能。 功能： 利率计算、通讯录获取、消息通知、弹幕、还款计划、借款计划、第三方支付 戴雅（已上线）应用链接 项目背景： 融资失败，项目后台已不能使用。是一款商城类APP主要针对文玩珠子。 开发部分： 除3D模块。 功能： 社区功能、银联支付、咨询功能、商品交易功能、3D展示功能、自定义3D模型功能","tags":[]},{"title":"SpringBoot开发Web应用","date":"2017-03-27T07:16:23.000Z","path":"/uncategorized/SpringBoot开发Web应用.html","text":"","tags":[]},{"title":"SpringBoot快速入门","date":"2017-03-27T07:15:53.000Z","path":"/uncategorized/SpringBoot快速入门.html","text":"","tags":[]},{"title":"Java常见对象之集合","date":"2017-03-27T07:14:44.000Z","path":"/uncategorized/Java常见对象之集合.html","text":"","tags":[]},{"title":"Java常见对象之字符串","date":"2017-03-27T07:14:03.000Z","path":"/uncategorized/Java常见对象之字符串.html","text":"","tags":[]},{"title":"Java面向对象","date":"2017-03-27T07:13:25.000Z","path":"/uncategorized/Java面向对象.html","text":"","tags":[]},{"title":"Java编程基础","date":"2017-03-27T07:12:19.000Z","path":"/uncategorized/Java编程基础.html","text":"本文来源于黑马J2EE培训教学笔记。博主又进行整理，掺杂自己的一些学习笔记，供大家学习。学习编程之前，我们首先要了解计算机的一些基本知识。本文讲解的一些基础知识，适合没有学习过计算机语言的小伙伴们了解。 本文知识点 计算机基础知识 常量与变量的使用 常见运算符的基本用法 流程控制语句 计算机基础知识计算机概述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是计算机? 计算机（Computer）全称：电子计算机，俗称电脑。是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成，没有安装任何软件的计算机称为裸机。常见的形式有台式计算机、笔记本计算机、大型计算机等。 计算机的应用举例 1：科学计算 2、数据处理 3、自动控制 4、计算机辅助设计 5、人工智能 6、多媒体应用 7、计算机网络 … &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是硬件?计算机硬件（Computer Hardware）是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础。 计算机的硬件分成5大组成部件：运算器、控制器、存储器、输入设备和输出设备。 运算器和控制器是计算机的核心，合称中央处理单元（Central Processing Unit，CPU）或处理器。CPU的内部还有一些高速存储单元，被称为寄存器。其中运算器执行所有的算术和逻辑运算；控制器负责把指令逐条从存储器中取出，经译码后向计算机发出各种控制命令；而寄存器为处理单元提供操作所需要的数据。 存储器是计算机的记忆部分，用来存放程序以及程序中涉及的数据。它分为内部存储器和外部存储器。内部存储器用于存放正在执行的程序和使用的数据，其成本高、容量小，但速度快。外部存储器可用于长期保存大量程序和数据，其成本低、容量大，但速度较慢。 输入设备和输出设备统称为外部设备，简称外设或I/O设备，用来实现人机交互和机间通信。微型机中常用的输入设备有键盘、鼠标等，输出设备有显示器、打印机等。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是软件?计算机软件(Computer Software)是使用计算机过程中必不可少的东西，计算机软件可以使计算机按照事先预定好的顺序完成特定的功能。计算机软件按照其功能划分为系统软件与应用软件： 系统软件： DOS(Disk Operating System), Windows, Linux, Unix, Mac, Android, iOS 应用软件：office QQ聊天 YY语言 扫雷 软件开发和计算机语言概述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是软件？软件就是按照特定顺序组织的计算机数据和指令的集合。什么是开发?简单来说开发就是软件的制作过程。什么是软件开发？借助开发工具与计算机语言制作软件。什么是计算机语言？人与计算机之间进行信息交流沟通的一种特殊语言。 计算机语言的分类 机器语言：机器语言是直接用二进制代码指令表达的计算机语言，指令是用0和1组成的一串代码，它们有一定的位数，并分成若干段，各段的编码表示不同的含义。 汇编语言：汇编语言是使用一些特殊的符号来代替机器语言的二进制码，计算机不能直接识别，需要用一种软件将汇编语言翻译成机器语言。 高级语言： 使用普通英语进行编写源代码，通过编译器将源代码翻译成计算机直接识别的机器语言，之后再由计算机执行。 高级语言包括C,C++,C#,JAVA 人机交互 A:人机交互的两种方式 a:命令行方式 需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令。 b:图形化界面方式 这种方式简单直观，使用者易于接受，容易上手操作。 常见的DOS命令在这里我们说一下windows系统中中常用的DOS命令有哪些，使用DOS命令需要先打开DOS控制台。 如何打开DOS控制台 xp下如何打开DOS控制台？ a:开始–程序–附件–命令提示符 b:开始–运行–cmd–回车 c:win+r–cmd–回车 win7下如何打开DOS控制台？ a:开始–所有程序–附件–命令提示符 b:开始–搜索程序和文件–cmd–回车 c:win+r–cmd–回车 win8下如何打开DOS控制台 a:鼠标左击开始–下箭头–命令提示符 b:鼠标右击开始–搜索–cmd–回车 c:鼠标右击开始–运行–cmd–回车 d:win+r–cmd–回车 DOS命令 d: 回车 盘符切换 dir(directory):列出当前目录下的文件以及文件夹 cd (change directory)改变指定目录(进入指定目录) cd.. : 退回到上一级目录 cd\\: 退回到根目录 cls : (clear screen)清屏 exit : 退出dos命令行 md (make directory) : 创建目录 rd (remove directory): 删除目录 del (delete): 删除文件,删除一堆后缀名一样的文件*.txt notepad 创建文件 删除带内容的文件夹 rd + /s 文件夹名称(询问是否删除) rd + /q + /s 文件夹名称(直接删除) Java语言基础Java语言概述Java语言发展史 詹姆斯·高斯林（James Gosling）1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司，1990年，与Patrick，Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak”，后改名为Java。 注：SUN(Stanford University Network，斯坦福大学网络公司) Java语言版本JDK 1.1.4 Sparkler 宝石 1997-09-12 JDK 1.1.5 Pumpkin 南瓜 1997-12-13 JDK 1.1.6 Abigail 阿比盖尔--女子名 1998-04-24 JDK 1.1.7 Brutus 布鲁图--古罗马政治家和将军 1998-09-28 JDK 1.1.8 Chelsea 切尔西--城市名 1999-04-08 J2SE 1.2 Playground 运动场 1998-12-04 J2SE 1.2.1 none 无 1999-03-30 J2SE 1.2.2 Cricket 蟋蟀 1999-07-08 J2SE 1.3 Kestrel 美洲红隼(sǔn) 2000-05-08 J2SE 1.3.1 Ladybird 瓢虫 2001-05-17 J2SE 1.4.0 Merlin 灰背隼 2002-02-13 J2SE 1.4.1 grasshopper 蚱蜢 2002-09-16 J2SE 1.4.2 Mantis 螳螂 2003-06-26 JAVASE 5.0 (1.5.0) Tiger 老虎 JAVASE 5.1 (1.5.1) Dragonfly 蜻蜓 JAVASE 6.0 (1.6.0) Mustang 野马 JAVASE 7.0 (1.7.0) Dolphin 海豚 Java语言平台J2SE(Java 2 Platform Standard Edition)标准版 是为开发普通桌面和商务应用程序提供的解决方案,该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发 J2ME(Java 2 Platform Micro Edition)小型版 是为开发电子消费产品和嵌入式设备提供的解决方案 J2EE(Java 2 Platform Enterprise Edition)企业版 是为开发企业环境下的应用程序提供的一套解决方案,该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发 Java语言特性 简单性 解释性 面向对象 高性能 分布式处理 多线程 健壮性 动态 结构中立 安全性 开源 跨平台 Java语言跨平台原理Java语言开发的应用可以在不同平台上运行。只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。 write once ,run anywhere!(一处编译,到处运行) JRE和JDK的概述 什么是JRE 包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 JRE:JVM+类库。 什么是JDK JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。 其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等 JDK:JRE+JAVA的开发工具。 为什么JDK中包含一个JRE 为什么JDK中包含一个JRE呢？ 开发完的程序，需要运行一下看看效果。 JDK的下载和安装过程图解 A:JDK的下载 a:官网 http://www.oracle.com b:演示下载流程 B:JDK的安装 a:傻瓜式安装 双击安装程序，然后一路next即可(但是不建议) b:安装的推荐方式 安装路径不要有中文或者特殊符号如空格等。 所有和开发相关的软件最好安装目录统一。 举例：我的JDK安装路径 D:\\develop\\Java\\jdk1.7.0_72 当提示安装JRE时，可以选择不安装。建议还是安装上。 c:演示安装流程 可以先在d盘建立一个文件夹develop 然后演示安装过程 C:验证安装是否成功 a:通过DOS命令，切换到JDK安装的bin目录下。 D:\\develop\\Java\\jdk1.7.0_72\\bin b:然后分别输入javac和java，如果正常显示一些内容，说明安装成功 JDK安装路径下的目录解释 a:bin目录：该目录用于存放一些可执行程序。 如javac.exe（java编译器）、java.exe(java运行工具)，jar.exe(打包工具)和* javadoc.exe(文档生成工具)等。 b:db目录：db目录是一个小型的数据库。 从JDK 6.0开始，Java中引用了一个新的成员JavaDB，这是一个纯Java实现、开源的数据库管理系统。这个数据库不仅轻便，而且支持JDBC 4.0所有的规范，在学习JDBC 时，不再需要额外地安装一个数据库软件，选择直接使用JavaDB即可。 c:jre目录：”jre”是 Java Runtime Environment 的缩写，意为Java程序运行时环境。此目录是Java运行时环境的根目录，它包括Java虚拟机，运行时的类包，Java应用启动器以及一个bin目录，但不包含开发环境中的开发工具。 d:include目录：由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是用于存放这些头文件的。 e:lib目录：lib是library的缩写，意为 Java 类库或库文件，是开发工具使用的归档包文件。 f:src.zip文件：src.zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码，通过该文件可以查看Java基础类的源代码。 Path环境变量的作用及配置方式1 A:在JDK的bin目录下开发程序容易产生的问题 a:如果文件过多，不方便管理 b:删除自己写过的不需要的文件，可能不小心把JDK自带的工具给删除了 B:如何解决问题呢 notepad这样的命令为什么在任何路径下都能够执行,配置path环境变量 C:配置方式 a:xp系统 右键点击桌面计算机→选择属性→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。 b:win7/win8系统 右键点击桌面计算机→选择属性→选择高级系统设置→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。 path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件 Path环境变量的配置方式2 A:先配置JAVA_HOME B:再修改path C:最后说一下path是有先后顺序关系的 classpath环境变量的作用及其配置 A:为什么要配置classpath B:classpath配置的原理 C:如何配置classpath path和classpath的区别 path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件 classpath配置的java的类文件,就是.class文件 Java开发工具介绍 A:notepad(微软操作系统自带) B:Editplus/Notepad++ C:Eclipse D:MyEclipse 给大家简单的介绍一下这些工具，然后说说我们使用这些工具的顺序。 基础班：先notepad，然后Editplus，再Eclipse。 就业班：MyEclipse和Eclipse都用。 Editplus开发程序并编译运行 A:配置快捷键编译运行 B:去除备份文件 第一个Java程序HelloWorld案例的编写和运行 A:定义类 B:写main方法 C:写输出语句 D:Java程序开发运行与工作原理 E:编译和运行程序 12345class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"HelloWorld\"); &#125;&#125; HelloWorld案例常见问题 A:找不到文件(都演示一下，让学生看看出现的都是什么问题) a:文件扩展名隐藏导致编译失败 b:文件名写错了 B:单词拼写问题(都演示一下，让学生看看出现的都是什么问题) a:class写成Class b:String写成string c:System写成system d:main写成mian C:括号匹配问题(都演示一下，让学生看看出现的都是什么问题) a:把类体的那对大括号弄掉一个 b:把方法体的那对大括号弄掉一个 c:把输出语句的那对小括号弄掉一个 D:中英文问题(都演示一下，让学生看看出现的都是什么问题) a:提示信息：错误: 非法字符: \\????的格式 注意：java编程中需要的基本上都是英文字符 Java语言的书写格式(约定俗成) 1,大括号要对齐,并且成对写 2,左大括号前面有空格 3,遇到左大括号要缩进,Tab 4,方法和程序块之间加空行让程序看起来清晰 5,并排语句之间加空格,例如for语句 6,运算符两侧加空格 注释概述及其分类 A:什么是注释 B:注释的分类及讲解 文档注释目前不讲，说后面讲解 注释的作用 A:解释说明程序 B:帮助我们调试错误 关键字的概述和使用 A:什么是关键字 被Java语言赋予特定含义的单词 B:关键字的特点 组成关键字的字母全部小写 C:常见关键字 public static void class等 D:关键字的注意事项 goto和const作为保留字存在,目前并不使用,类似Editplus这样的高级记事本,针对关键字有特殊的颜色标记，非常直观 标识符的概述和组成规则 A:什么是标识符 就是给类,接口,方法,变量等起名字时使用的字符序列 B:标识符的组成规则 英文大小写字母 数字字符 $和_ C:标识符注意事项 1,不能使用关键字 2,不能数字开头 标识符中常见的命名规则 见名知意 A:包 最好是域名倒过来,要求所有的字母小写 B:类或者接口 如果是一个单词首字母大写 如果是多个单词每个单词首字母大写(驼峰标识) C:方法或者变量 如果是一个单词全部小写 如果是多个单词,从第二个单词首字母大写 D:常量 如果是一个单词,所有字母大写 如果是多个单词,所有的单词大写,用下划线区分每个单词 常量与进制转换常量的概述和使用 A:什么是常量 在程序执行的过程中其值不可以发生改变 B:Java中常量的分类 字面值常量 自定义常量(面向对象部分讲) C:字面值常量的分类 字符串常量 用双引号括起来的内容 整数常量 所有整数 小数常量 所有小数 字符常量 用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号 布尔常量 较为特殊，只有true和false 空常量 null(数组部分讲解) D:案例演示 用输出语句输出各种常量。null不演示 进制概述和二,八,十六进制图解 A:什么是进制 进制：就是进位制，是人们规定的一种进位方法。 对于任何一种进制–X进制，就表示某一位置上的数运算时是逢X进一位。二进制就是逢二进一，八进制是逢八进一，十进制是逢十进一，十六进制是逢十六进一。 例如一周有七天,七进制,一年有十二个月,十二进制 B:十进制的由来 十进制的由来是因为人类有十个手指 C:二进制的由来 其实二进制来源与中国,请看史料记载 18世纪德国数理哲学大师莱布尼兹从他的传教士朋友鲍威特寄给他的拉丁文译本《易经》中，读到了八卦的组成结构，惊奇地发现其基本素数（0）（1），即《易经》的阴爻yao- -和__阳爻，其进位制就是二进制，并认为这是世界上数学进制中最先进的。20世纪被称作第三次科技革命的重要标志之一的计算机的发明与应用，其运算模式正是二进制。它不但证明了莱布尼兹的原理是正确的，同时也证明了《易经》数理学是很了不起的。 D:八进制的由来 任何数据在计算机中都是以二进制的形式存在的。二进制早期由电信号开关演变而来。一个整数在内存中一样也是二进制的，但是使用一大串的1或者0组成的数值进行使用很麻烦。 所以就想把一大串缩短点，将二进制中的三位用一位表示。这三位可以取到的最大值就是7.超过7就进位了，这就是八进制。 E:十六进制的由来 但是对于过长的二进制变成八进制还是较长，所以出现的用4个二进制位表示一位的情况，四个二进制位最大是15，这就是十六进制。 F:不同进制表现同一个数据的形式特点 进制越大，表现形式越短 不同进制数据的表现形式 A:二进制的数据表现形式 由0,1组成。以0b(b可以大写也可以小写)开头(JDK1.7版本可以表示二进制了) B:八进制的数据表现形式 由0,1,…7组成。以0开头 C:十进制的数据表现形式 由0,1,…9组成。整数默认是十进制的 D:十六进制的数据表现形式 由0,1,…9,a,b,c,d,e,f(大小写均可)。以0x开头 E:案例演示 输出不同进制表现100的数据。 0b100 0100 100 0x100 任意进制到十进制的转换图解 A:任意进制到十进制的转换原理 系数：就是每一位上的数据。 基数：X进制，基数就是X。 权：在右边，从0开始编号，对应位上的编号即为该位的权。 结果：把系数*基数的权次幂相加即可。 B:画图练习 二进制–十进制 八进制–十进制 十六进制–十进制 十进制到任意进制的转换图解 A:十进制到任意进制的转换原理 除积倒取余 B:画图练习 十进制–二进制 十进制–八进制 十进制–十六进制 快速的进制转换法 A:8421码及特点 8421码是中国大陆的叫法，8421码是BCD代码中最常用的一种。在这种编码方式中每一位二值代码的1都是代表一个固定数值，把每一位的1代表的十进制数加起来，得到的结果就是它所代表的十进制数码。 B:通过8421码的方式进行二进制和十进制的相互转换 C:二进制到八进制的简易方式 D:二进制到十六进制的简易方式 原码反码补码 A:为什么要学习原码反码补码? 后面要学习强制类型转换,如果不知道有原反补会看不懂结果 B:有符号数据表示法的几种方式 原码 就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。 通过一个字节,也就是8个二进制位表示+7和-7 0(符号位) 0000111 1(符号位) 0000111 反码 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码 正数的补码与其原码相同；负数的补码是在其反码的末位加1。 A:已知原码求补码 0b10110100 B:已知补码求原码 0b11101110 变量与数据类型转换变量的概述及格式 A:什么是变量 在程序执行的过程中，在某个范围内其值可以发生改变的量 B:变量的定义格式 数据类型 变量名 = 变量值; C:为什么要定义变量 用来不断的存放同一类型的常量，并可以重复使用 数据类型的概述和分类 A:为什么有数据类型 Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间 B:Java中数据类型的分类 基本数据类型 引用数据类型 面向对象部分讲解 C:基本数据类型分类(4类8种) 整数型 byte 占一个字节 -128到127 short 占两个字 -2^15~2^15-1 int 占四个字节 -2^31~2^31-1 long 占八个字节 -2^63~2^63-1 浮点型 float 占四个字节 -3.403E38~3.403E38 单精度 double 占八个字节-1.798E308~1.798E308 双精度 字符型 char 占两个字节 0~65535 布尔型 boolean boolean理论上是占八分之一个字节,因为一个开关就可以决定是true和false了,但是java中boolean类型没有明确指定他的大小 定义不同数据类型的变量 A:案例演示 定义不同基本数据类型的变量，并输出 赋值时候注意float类型,long类型 使用变量的注意事项 A:案例演示 a:作用域问题 同一个区域不能使用相同的变量名 b:初始化值问题 局部变量在使用之前必须赋值 c:一条语句可以定义几个变量 int a,b,c…; 数据类型转换之隐式转换 A:案例演示 a:int + int b:byte + int B:Java中的默认转换规则 取值范围小的数据类型与取值范围大的数据类型进行运算,会先将小的数据类型提升为大的,再运算 C:画图解释byte+int类型的问题 数据类型转换之强制转换 A:强制转换问题 int a = 10; byte b = 20; b = a + b; B:强制转换的格式 b = (byte)(a + b); C:强制转换的注意事项 如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同 面试题之变量相加和常量相加的区别 A:案例演示 面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。 byte b1 = 3; byte b2 = 4; byte b3 = b1 + b2; 从两方面去回答这个题 b1和b2是两个变量,变量里面存储的值都是变化的,所以在程序运行中JVM是无法判断里面具体的值 byte类型的变量在进行运算的时候,会自动类型提升为int类型 byte b4 = 3 + 4; 3和4都是常量,java有常量优化机制,就是在编译的的时候直接把3和4的结果赋值给b4了 long与float的取值范围谁大谁小 进行混合运算的时候,byte,short,char不会相互转换,都会自动类型提升为int类型,其他类型进行混合运算的是小的数据类型提升为大的 byte,short,char – int – long – float – double long: 8个字节 float：4个字节 IEEE754 4个字节是32个二进制位 1位是符号位 8位是指数位 00000000 11111111 0到255 1到254 -126到127 23位是尾数位 每个指数位减去127 A:它们底层的存储结构不同。 B:float表示的数据范围比long的范围要大 long：2^63-1 float：3.410^38 &gt; 210^38 &gt; 28^38 = 22^3^38 = 2*2^114 &gt; 2^63-1 字符和字符串参与运算 A:案例演示 System.out.println(‘a’); System.out.println(‘a’+1); 通过看结果知道’a’的值是多少,由此引出ASCII码表 B:ASCII码表的概述 记住三个值： ‘0’ 48 ‘A’ 65 ‘a’ 97 C:案例演示 System.out.println(“hello”+’a’+1); System.out.println(‘a’+1+”hello”); D:+在有字符串参与中被称为字符串连接符 System.out.println(“5+5=”+5+5); System.out.println(5+5+”=5+5”); char数据类型 A:char c = 97; 0到65535 B:Java语言中的字符char可以存储一个中文汉字吗?为什么呢? 可以。因为Java语言采用的是Unicode编码。Unicode编码中的每个字符占用两个字节。中文也是占的两个字节 所以，Java中的字符可以存储一个中文汉字 运算符算术运算符的基本用法 A:什么是运算符 就是对常量和变量进行操作的符号。 B:运算符的分类 算术运算符，赋值运算符，比较(关系或条件)运算符，逻辑运算符，位运算符，三目(元)运算符 C:算数运算符有哪些 +,-,*,/,%,++,– D:注意事项： a:+号在java中有三种作用,代表正号,做加法运算,字符串的连接符 b:整数相除只能得到整数。如果想得到小数，必须把数据变化为浮点数类型 c:/获取的是除法操作的商，%获取的是除法操作的余数 %运算符 当左边的绝对值小于右边绝对值时,结果是左边 当左边的绝对值等于右边或是右边的倍数时,结果是0 当左边的绝对值大于右边绝对值时,结果是余数 %运算符结果的符号只和左边有关系,与右边无关 任何一个正整数%2结果不是0就是1可以用来当作切换条件 算术运算符++和–的用法 A:++,–运算符的作用 自加（++）自减（–）运算 ++:自加。对原有的数据进行+1 –:自减。对原有的数据进行-1 B:案例演示 a:单独使用： 放在操作数的前面和后面效果一样。(这种用法是我们比较常见的) b:参与运算使用： 放在操作数的前面，先自增或者自减，然后再参与运算。 放在操作数的后面，先参与运算，再自增或者自减。 算术运算符++和–的练习 A:案例演示 请分别计算出a,b,c的值? 12345678int a = 10;int b = 10;int c = 10; a = b++; c = --a; b = ++a; a = c--; B:案例演示 请分别计算出x,y的值? 12int x = 4;int y = (x++)+(++x)+(x*10); C:面试题 byte b = 10; b++; b = b + 1; 问哪句会报错,为什么 赋值运算符的基本用法 A:赋值运算符有哪些 a:基本的赋值运算符：= 把=右边的数据赋值给左边。 b:扩展的赋值运算符：+=,-=,*=,/=,%= += 把左边和右边做加法，然后赋值给左边。 赋值运算符的面试题 A:案例演示 面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。 short s=1;s = s+1; short s=1;s+=1; 关系运算符的基本用法及其注意事项 A:关系运算符有哪些(比较运算符,条件运算符) ==,!=,&gt;,&gt;=,&lt;,&lt;= 注意事项： 无论你的操作是简单还是复杂，结果是boolean类型。 “==”不能写成”=”。 逻辑运算符的基本用法 A:逻辑运算符有哪些 &amp;,|,^,! &amp;&amp;,|| B:案例演示 逻辑运算符的基本用法 注意事项： a:逻辑运算符一般用于连接boolean类型的表达式或者值。 b:表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。 算术表达式：a + b 比较表达式：a == b(条件表达式) C:结论： &amp;逻辑与:有false则false。 |逻辑或:有true则true。 ^逻辑异或:相同为false，不同为true。 !逻辑非:非false则true，非true则false。 特点：偶数个不改变本身。 逻辑运算符&amp;&amp;和&amp;的区别 A:案例演示 &amp;&amp;和&amp;的区别? a:最终结果一样。 b:&amp;&amp;具有短路效果。左边是false，右边不执行。 &amp;是无论左边是false还是true,右边都会执行 B:同理||和|的区别?(学生自学) C:开发中常用谁? &amp;&amp;,||,! 位运算符的基本用法 A:位运算符有哪些 &amp;,|,^,~ ,&gt;&gt;,&gt;&gt;&gt;,&lt;&lt; B:案例演示 位运算符的基本用法1 &amp;,|,^,~ 的用法 &amp;:有0则0 |:有1则1 ^:相同则0，不同则1 ~:按位取反 位异或运算符的特点及面试题 A:案例演示 位异或运算符的特点 ^的特点：一个数据对另一个数据位异或两次，该数本身不变。 B:面试题： 请自己实现两个整数变量的交换 注意：以后讲课的过程中，我没有明确指定数据的类型，默认int类型。 位运算符的基本用法2及面试题 A:案例演示 &gt;&gt;,&gt;&gt;&gt;,&lt;&lt;的用法: &lt;&lt;:左移 左边最高位丢弃，右边补齐0 :右移 最高位是0，左边补齐0;最高为是1，左边补齐1 :无符号右移 无论最高位是0还是1，左边补齐0 最有效率的算出2 * 8的结果 三元运算符的基本用法 A:三元运算符的格式 (关系表达式) ? 表达式1 : 表达式2; B:三元运算符的执行流程 C:案例演示 获取两个数中的最大值 三元运算符的练习 A:案例演示 比较两个整数是否相同 B:案例演示 获取三个整数中的最大值 键盘录入键盘录入的基本格式讲解 A:为什么要使用键盘录入数据 a:为了让程序的数据更符合开发的数据 b:让程序更灵活一下 B:如何实现键盘录入呢? 先照格式来。 a:导包 格式： import java.util.Scanner; 位置： 在class上面。 b:创建键盘录入对象 格式： Scanner sc = new Scanner(System.in); c:通过对象获取数据 格式： int x = sc.nextInt(); C:案例演示 键盘录入1个整数，并输出到控制台。 键盘录入2个整数，并输出到控制台。 键盘录入的练习1 A:案例演示 键盘录入练习：键盘录入两个数据，并对这两个数据求和，输出其结果 B:案例演示 键盘录入练习：键盘录入两个数据，获取这两个数据中的最大值 键盘录入的练习2 A:案例演示 键盘录入练习：键盘录入两个数据，比较这两个数据是否相等 B:案例演示 键盘录入练习：键盘录入三个数据，获取这三个数据中的最大值 流程控制语句 A:什么是流程控制语句 流程控制语句：可以控制程序的执行流程。 B:流程控制语句的分类 顺序结构 选择结构 循环结构 C:执行流程： 从上往下，依次执行。 D:案例演示 输出几句话看效果即可 选择结构if语句格式1及其使用 A:选择结构的分类 if语句 switch语句 B:if语句有几种格式 格式1 格式2 格式3 C:if语句的格式1 123if(比较表达式) &#123; 语句体; &#125; D:执行流程： 先计算比较表达式的值，看其返回值是true还是false。 如果是true，就执行语句体； 如果是false，就不执行语句体； 选择结构if语句注意事项 A:案例演示 a:比较表达式无论简单还是复杂，结果必须是boolean类型 b:if语句控制的语句体如果是一条语句，大括号可以省略； 如果是多条语句，就不能省略。建议永远不要省略。 c:一般来说：有左大括号就没有分号，有分号就没有左大括号 选择结构if语句格式2及其使用 A:if语句的格式2 12345if(比较表达式) &#123; 语句体1;&#125;else &#123; 语句体2;&#125; B:执行流程： 首先计算比较表达式的值，看其返回值是true还是false。 如果是true，就执行语句体1； 如果是false，就执行语句体2； C:案例演示 a:获取两个数据中较大的值 b:判断一个数据是奇数还是偶数,并输出是奇数还是偶数 注意事项：else后面是没有比较表达式的，只有if后面有。 if语句的格式2和三元的相互转换问题 A:案例演示 if语句和三元运算符完成同一个效果 B:案例演示 if语句和三元运算符的区别 三元运算符实现的，都可以采用if语句实现。反之不成立。 什么时候if语句实现不能用三元改进呢? 当if语句控制的操作是一个输出语句的时候就不能。 为什么呢?因为三元运算符是一个运算符，运算符操作完毕就应该有一个结果，而不是一个输出。 选择结构if语句格式3及其使用 A:if语句的格式3： 1234567891011if(比较表达式1) &#123; 语句体1;&#125;else if(比较表达式2) &#123; 语句体2;&#125;else if(比较表达式3) &#123; 语句体3;&#125;...else &#123; 语句体n+1;&#125; B:执行流程： 首先计算比较表达式1看其返回值是true还是false， 如果是true，就执行语句体1，if语句结束。 如果是false，接着计算比较表达式2看其返回值是true还是false， 如果是true，就执行语句体2，if语句结束。 如果是false，接着计算比较表达式3看其返回值是true还是false， 如果都是false，就执行语句体n+1。 C:注意事项:最后一个else可以省略,但是建议不要省略,可以对范围外的错误值提示 选择结构if语句格式3练习 A:练习1 123456需求：键盘录入一个成绩，判断并输出成绩的等级。90-100 优80-89 良70-79 中60-69 及0-59 差 B:练习2 需求： 键盘录入x的值，计算出y的并输出。 x&gt;=3 y = 2 * x + 1; -1&lt;x&lt;3 y = 2 * x; x&lt;=-1 y = 2 * x - 1; 选择结构if语句的嵌套使用 A:案例演示 需求：获取三个数据中的最大值 if语句的嵌套使用。 选择结构switch语句的格式及其解释 A:switch语句的格式 123456789101112switch(表达式) &#123; case 值1： 语句体1; break; case 值2： 语句体2; break; … default： 语句体n+1; break; &#125; B:switch语句的格式解释 C:面试题 byte可以作为switch的表达式吗? long可以作为switch的表达式吗? String可以作为switch的表达式吗? C:执行流程 先计算表达式的值 然后和case后面的匹配，如果有就执行对应的语句，否则执行default控制的语句 选择结构switch语句的练习 A:整数(给定一个值,输出对应星期几) 选择结构switch语句的注意事项 A:案例演示 a:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 b:default可以省略吗? 可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。 特殊情况： case就可以把值固定。 A,B,C,D c:break可以省略吗? 最后一个可以省略,其他最好不要省略 会出现一个现象：case穿透。 最终我们建议不要省略 d:default一定要在最后吗? 不是，可以在任意位置。但是建议在最后。 e:switch语句的结束条件 a:遇到break就结束了 b:执行到switch的右大括号就结束了 选择结构switch语句练习 A:看程序写结果： 123456789101112int x = 2;int y = 3;switch(x)&#123; default: y++; break; case 3: y++; case 4: y++;&#125;System.out.println(\"y=\"+y); B:看程序写结果： 1234567891011int x = 2;int y = 3;switch(x)&#123; default: y++; case 3: y++; case 4: y++;&#125;System.out.println(\"y=\"+y); 选择结构if语句和switch语句的区别 A:总结switch语句和if语句的各自使用场景 switch建议判断固定值的时候用 if建议判断区间或范围的时候用 B:案例演示 分别用switch语句和if语句实现下列需求： 键盘录入月份，输出对应的季节 循环结构概述 A:循环结构的分类 for,while,do…while for语句的格式及其使用 B:循环结构for语句的格式： 123for(初始化表达式;条件表达式;循环后的操作表达式) &#123; 循环体;&#125; C执行流程： a:执行初始化语句 b:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 c:执行循环体语句; d:执行循环后的操作表达式 e:回到B继续。 D:案例演示 在控制台输出10次”helloworld” for语句的练习之获取数据 A:案例演示 需求：请在控制台输出数据1-10 需求：请在控制台输出数据10-1 B:注意事项 a:判断条件语句无论简单还是复杂结果是boolean类型。 b:循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。 c:一般来说：有左大括号就没有分号，有分号就没有左大括号 for语句的练习之求和思想 A:案例演示 需求：求出1-10之间数据之和 B:学生练习 需求：求出1-100之间偶数和 需求：求出1-100之间奇数和 for语句的练习之水仙花 A:案例演示 需求：在控制台输出所有的”水仙花数” 所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。 举例：153就是一个水仙花数。 153 = 111 + 555 + 333 = 1 + 125 + 27 = 153 for语句的练习之统计思想 A:案例演示 需求：统计”水仙花数”共有多少个 while语句的格式和基本使用 A:循环结构while语句的格式： 123456789101112while循环的基本格式：while(判断条件语句) &#123; 循环体语句;&#125;完整格式：初始化语句; while(判断条件语句) &#123; 循环体语句; 控制条件语句;&#125; B:执行流程： a:执行初始化语句 b:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 c:执行循环体语句; d:执行控制条件语句 e:回到B继续。 C:案例演示 需求：请在控制台输出数据1-10 while语句的练习 A:求和思想 求1-100之和 B:统计思想 统计”水仙花数”共有多少个 do…while语句的格式和基本使用 A:循环结构do…while语句的格式： 12345678910do &#123; 循环体语句;&#125;while(判断条件语句);完整格式；初始化语句;do &#123; 循环体语句; 控制条件语句;&#125;while(判断条件语句); B:执行流程： a:执行初始化语句 b:执行循环体语句; c:执行控制条件语句 d:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 e:回到b继续。 C:案例演示 需求：请在控制台输出数据1-10 三种循环语句的区别 A:案例演示 三种循环语句的区别: do…while循环至少执行一次循环体。 而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。 B:案例演示 for循环和while循环的区别： A:如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用谁就用for循环。因为变量及早的从内存中消失，可以提高内存的使用效率。 注意事项之死循环 A:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。 B:两种最简单的死循环格式 while(true){…} for(;;){…} 循环嵌套输出4行5列的星星 A:案例演示 需求：请输出一个4行5列的星星(*)图案。 如图： ***** ***** ***** ***** 注意： System.out.println(&quot;*&quot;);和System.out.print(&quot;*&quot;);的区别 B:结论： 外循环控制行数，内循环控制列数 循环嵌套输出正三角形 A:案例演示 需求：请输出下列的形状 * ** *** **** ***** 九九乘法表 A:案例演示 需求：在控制台输出九九乘法表。 B:代码优化 注意： &apos;\\x&apos; x表示任意，\\是转义符号,这种做法叫转移字符。 &apos;\\t&apos; tab键的位置 &apos;\\r&apos; 回车 &apos;\\n&apos; 换行 &apos;\\&quot;&apos; &apos;\\&apos;&apos; 控制跳转语句break语句 A:break的使用场景 只能在switch和循环中 控制跳转语句continue语句 A:continue的使用场景 只能在循环中 控制跳转语句标号 标号:标记某个循环对其控制 标号组成规则:其实就是合法的标识符 控制调整语句练习 A:练习题 12345678910for(int x=1; x&lt;=10; x++) &#123; if(x%3==0) &#123; //在此处填写代码 &#125; System.out.println(“Java基础班”);&#125;我想在控制台输出2次:“Java基础班“我想在控制台输出7次:“Java基础班“我想在控制台输出13次:“Java基础班“ 控制跳转语句return语句 A:return的作用 返回 其实它的作用不是结束循环的，而是结束方法的。 B:案例演示 return和break以及continue的区别? return是结束方法 break是跳出循环 continue是终止本次循环继续下次循环 方法方法概述和格式说明 A:为什么要有方法 提高代码的复用性 B:什么是方法 完成特定功能的代码块。 C:方法的格式 1234修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) &#123; 方法体语句; return 返回值; &#125; D:方法的格式说明 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 返回值类型：就是功能结果的数据类型。 方法名：符合命名规则即可。方便我们的调用。 参数： 实际参数：就是实际参与运算的。 形式参数；就是方法定义上的，用于接收实际参数的。 参数类型：就是参数的数据类型 参数名：就是变量名 方法体语句：就是完成功能的代码。 return：结束方法的。 返回值：就是功能的结果，由return带给调用者。 方法之求和案例及其调用 A:如何写一个方法 1,明确返回值类型 2,明确参数列表 B:案例演示 需求：求两个数据之和的案例 C:方法调用图解 方法的注意事项 A:方法调用(有具体返回值) a:单独调用,一般来说没有意义，所以不推荐。 b:输出调用,但是不够好。因为我们可能需要针对结果进行进一步的操作。 c:赋值调用,推荐方案。 B:案例演示 a:方法不调用不执行 b:方法与方法是平级关系，不能嵌套定义 c:方法定义的时候参数之间用逗号隔开 d:方法调用的时候不用在传递数据类型 e:如果方法有明确的返回值，一定要有return带回一个值 方法的练习 A:案例演示 需求：键盘录入两个数据，返回两个数中的较大值 B:案例演示 需求：键盘录入两个数据，比较两个数是否相等 方法之输出星形及其调用 A:案例演示 需求：根据键盘录入的行数和列数，在控制台输出星形 B:方法调用：(无返回值,void) 单独调用 输出调用(错误) 赋值调用(错误) 方法的练习2 A:案例演示 需求：根据键盘录入的数据输出对应的乘法表 方法重载概述和基本使用 A:方法重载概述 求和案例 2个整数 3个整数 4个整数 B:方法重载： 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 参数列表不同： A:参数个数不同 B:参数类型不同 C:参数的顺序不同(算重载,但是在开发中不用) 方法重载练习比较数据是否相等 A:案例演示 需求：比较两个数据是否相等。 参数类型分别为两个int类型，两个double类型，并在main方法中进行测试 数组数组概述和定义格式说明 A:为什么要有数组(容器) 为了存储同种数据类型的多个值 B:数组概念 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。 数组既可以存储基本数据类型，也可以存储引用数据类型。 C:数组定义格式 数据类型[] 数组名 = new 数据类型[数组的长度]; 数组的初始化动态初始化 A:什么是数组的初始化 就是为数组开辟连续的内存空间，并为每个数组元素赋予值 B:如何对数组进行初始化 a:动态初始化 只指定长度，由系统给出初始化值 int[] arr = new int[5]; b:静态初始化 给出初始化值，由系统决定长度 C:动态初始化的格式： 数据类型[] 数组名 = new 数据类型[数组长度]; D:案例演示 输出数组名称和数组元素 Java中的内存分配以及栈和堆的区别 A:栈(掌握) 存储局部变量 B:堆(掌握) 存储new出来的数组或对象 C:方法区 面向对象部分讲解 D:本地方法区 和系统相关 E:寄存器 给CPU使用数组的内存图解1一个数组 A:画图演示 一个数组 数组的内存图解2二个数组 A:画图演示 二个不同的数组 数组的内存图解3三个引用两个数组 A:画图演示 三个引用，有两个数组的引用指向同一个地址 数组的初始化静态初始化及内存图 A:静态初始化的格式： 格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…}; 简化格式： 数据类型[] 数组名 = {元素1,元素2,…}; B:案例演示 对数组的解释 输出数组名称和数组元素 C:画图演示 一个数组 数组操作的两个常见小问题越界和空指针 A:案例演示 a:ArrayIndexOutOfBoundsException:数组索引越界异常 原因：你访问了不存在的索引。 b:NullPointerException:空指针异常 原因：数组已经不在指向堆内存了。而你还用数组名去访问元素。 int[] arr = {1,2,3}; arr = null; System.out.println(arr[0]); 数组的操作1遍历 A:案例演示 数组遍历：就是依次输出数组中的每一个元素。 数组的属性:arr.length数组的长度 数组的最大索引:arr.length - 1; 12345public static void print(int[] arr) &#123; for (int i = 0;i &lt; arr.length ;i++ ) &#123; System.out.print(arr[i] + \" \"); &#125;&#125; 数组的操作2获取最值 A:案例演示 数组获取最值(获取数组中的最大值最小值) 12345678910public static int getMax(int[] arr) &#123; int max = arr[0]; for (int i = 1;i &lt; arr.length ;i++ ) &#123; //从数组的第二个元素开始遍历 if (max &lt; arr[i]) &#123; //如果max记录的值小于的数组中的元素 max = arr[i]; //max记录住较大的 &#125; &#125; return max;&#125; 数组的操作3反转 A:案例演示 数组元素反转(就是把元素对调) 123456789101112public static void reverseArray(int[] arr) &#123; for (int i = 0;i &lt; arr.length / 2 ; i++) &#123; //arr[0]和arr[arr.length-1-0]交换 //arr[1]和arr[arr.length-1-1]交换 //arr[2]和arr[arr.lentth-1-2] //... int temp = arr[i]; arr[i] = arr[arr.length-1-i]; arr[arr.length-1-i] = temp; &#125;&#125; 数组的操作4查表法 A:案例演示 数组查表法(根据键盘录入索引,查找对应星期) 1234public static char getWeek(int week) &#123; char[] arr = &#123;' ','一','二','三','四','五','六','日'&#125;; //定义了一张星期表 return arr[week]; //通过索引获取表中的元素&#125; 数组的操作5基本查找 A:案例演示 数组元素查找(查找指定元素第一次在数组中出现的索引) 12345678public static int getIndex(int[] arr,int value) &#123; for (int i = 0;i &lt; arr.length ;i++ ) &#123; //数组的遍历 if (arr[i] == value) &#123; //如果数组中的元素与查找的元素匹配 return i; &#125; &#125; return -1;&#125; 二维数组概述和格式1的讲解 A:二维数组概述 B:二维数组格式1 int[][] arr = new int[3][2]; C:二维数组格式1的解释 D:注意事项 a:以下格式也可以表示二维数组 1:数据类型 数组名[][] = new 数据类型[m][n]; 2:数据类型[] 数组名[] = new 数据类型[m][n]; B:注意下面定义的区别 int x; int y; int x,y; int[] x; int[] y[]; int[] x,y[]; x是一维数组,y是二维数组 E:案例演示 定义二维数组，输出二维数组名称，一维数组名称，一个元素 二维数组格式1的内存图解 A:画图演示 画图讲解上面的二维数组名称，一维数组名称，一个元素的值的问题 二维数组格式2的讲解及其内存图解 A:二维数组格式2 int[][] arr = new int[3][]; B:二维数组格式2的解释 C:案例演示 讲解格式，输出数据，并画内存图 二维数组格式3的讲解及其内存图解 A:二维数组格式3 int[][] arr = {{1,2,3},{4,5},{6,7,8,9}}; B:二维数组格式3的解释 C:案例演示 讲解格式，输出数据，并画内存图 二维数组练习1遍历 A:案例演示 需求：二维数组遍历 外循环控制的是二维数组的长度，其实就是一维数组的个数。 内循环控制的是一维数组的长度。 123456789int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8,9&#125;&#125;; for (int i = 0;i &lt; arr.length ;i++ ) &#123; //获取到每个二维数组中的一维数组 for (int j = 0;j &lt; arr[i].length ;j++ ) &#123; //获取每个一维数组中的元素 System.out.print(arr[i][j] + \" \"); &#125; System.out.println();&#125; 二维数组练习2求和 A:案例演示 需求：公司年销售额求和 某公司按照季度和月份统计的数据如下：单位(万元) 第一季度：22,66,44 第二季度：77,33,88 第三季度：25,45,65 第四季度：11,66,99 12345678910int[][] arr = &#123;&#123;22,66,44&#125;,&#123;77,33,88&#125;,&#123;25,45,65&#125;,&#123;11,66,99&#125;&#125;;int sum = 0; //定义变量,记录每次相加的结果for (int i = 0;i &lt; arr.length ;i++ ) &#123; //获取每一个一维数组 for (int j = 0;j &lt; arr[i].length ;j++ ) &#123; //获取每一个一维数组中的元素 sum = sum + arr[i][j]; //累加 &#125;&#125;System.out.println(sum); 思考题Java中的参数传递问题及图解 A:案例演示 看程序写结果，并画内存图解释 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println(\"a:\"+a+\",b:\"+b); change(a,b); System.out.println(\"a:\"+a+\",b:\"+b); int[] arr = &#123;1,2,3,4,5&#125;; change(arr); System.out.println(arr[1]);&#125; public static void change(int a,int b) &#123; System.out.println(\"a:\"+a+\",b:\"+b); a = b; b = a + b; System.out.println(\"a:\"+a+\",b:\"+b);&#125; public static void change(int[] arr) &#123; for(int x=0; x&lt;arr.length; x++) &#123; if(arr[x]%2==0) &#123; arr[x]*=2; &#125; &#125;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://www.aiwyt.com/tags/编程/"},{"name":"java","slug":"java","permalink":"http://www.aiwyt.com/tags/java/"}]},{"title":"程序猿常用网站推荐","date":"2017-03-27T07:09:21.000Z","path":"/uncategorized/程序猿常用网站推荐.html","text":"","tags":[]},{"title":"Mac下好用的应用集合","date":"2017-03-27T07:07:20.000Z","path":"/uncategorized/Mac下好用的应用集合.html","text":"","tags":[]},{"title":"Markdown基础应用","date":"2017-03-27T07:05:38.000Z","path":"/uncategorized/Markdown基础应用.html","text":"","tags":[]},{"title":"使用hexo搭建GitHub博客","date":"2017-03-27T03:26:59.000Z","path":"/uncategorized/使用hexo搭建GitHub博客.html","text":"最近在学习Java开发，开始的时候使用有道云笔记，记了些笔记希望可以分享给其他人，觉得有道云笔记分享比较麻烦，只能单篇的分享出去。就想找一个博客平台在上面写，看了csdn，博客园，简书等，发现都不能合自己心意。就准备自己搭建一个博客，之后根据自己的喜好自定义，完善。下面就是我搭建博客的过程： 本文主要讲解，如何使用GitHub+Hexo搭建个人博客，因本人使用的是MacBook Air 所以，该文章是基于苹果的Mac osx操作系统，windows操作系统搭建方法大同小异。 Github准备注册GitHub账号注册GitHub账号这里我们就不多说了，大家可以直接进入GitHub官网注册。 创建仓库登录账号后，在Github页面右上方选择New repository创建一个新的仓库。 (图片来自简书) (图片来自简书) 在Repository name输入框中 输入： 你的github名字.github.io 然后点击Create repository即可 生成秘钥 在终端（Terminal)输入： ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 一直Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入https://github.com/settings/ssh： (图片来自简书)将复制的内容粘贴到Key的输入框，随便写好Title里面的内容，点击Add SSH key按钮即可。## 安装node.js点击进入node.js官网(图片来自node.js官网) 目前node.js有两个推荐版本，分为通用版和最新版，本文使用v.7.7.4版本，点击可直接进行下载。下载安装即可。 安装完成后，进入终端（Terminal)输入： npm -v node -v 如下图显示版本号，安装成功。 安装Git因Mac 安装Xcode后就会安装有Git，这里就不多说。如果您的电脑没有安装Git，可前往Git官网下载安装即可。 (图片来自简书) 安装配置hexo (图片来自简书)接下来我们的操作都将在Terminal终端进行： 定位博客本地放置的路径1$ cd 文件夹注：这个文件夹，最好不要选择需要管理员权限才能创建的文件夹 下载安装Hexo1$ npm install -g hexo-cli安装好hexo后，继续在终端输入：1$ hexo若出现如下图，则说明安装成功:(图片来自简书) 初始化博客 123456&lt;!-- 建立一个博客文件夹，并初始化博客，&lt;folder&gt;为文件夹的名称，可以随便起名字 --&gt;$ hexo init &lt;folder&gt; // 进入博客文件夹，&lt;folder&gt;为文件夹的名称$ cd &lt;folder&gt;// node.js的命令，根据博客既定的dependencies配置安装所有的依赖包$ npm install 初始化博客以后，我们可以看到博客文件夹里的文件是这样的： 配置博客 基于上一步，我们对博客修改相应的配置，我们用到_config.yml文件，下面是该文件的默认参数信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: # The title of your websitesubtitle: # The subtitle of your websitedescription: # The description of your websiteauthor: # Your namelanguage: # The language of your websitetimezone: # URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.com/childroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 这些配置中，很多是不需要我们去修改设置的，我们只要修改下面的几个配置接可以了： 修改网站相关信息 123456title: inerdstacksubtitle: the stack of it nerdsdescription: start from zeroauthor: inerdstacklanguage: zh-CNtimezone: Asia/Shanghai language和timezone都是有输入规范的，详细可参考语言规范和时区规范。 注意：每一项的填写，其:后面都要保留一个空格，下同。 个人域名1url: http://aiwyt.com 对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。 配置部署1234deploy: type: git repo: https://github.com/false7518/false7518.github.io branch: master 其中repo项是之前Github上创建好的仓库的地址，可以通过如下图所示的方式得到： Branch是项目的分支，我们默认用主分支master。 发表一篇文章在终端输入： 12// 新建一篇文章hexo new &quot;文章标题&quot; 我们可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件用Markdown编辑器打开文件，我们可以看到这样的内容：我们写下: 123&gt;最近在学习Java开发，开始的时候使用有道云笔记，记了些笔记希望可以分享给其他人，觉得有道云笔记分享比较麻烦，只能单篇的分享出去。&gt;就想找一个博客平台在上面写，看了csdn，博客园，简书等，发现都不能合自己心意。&gt;就准备自己搭建一个博客，之后根据自己的喜好自定义，完善。下面就是我搭建博客的过程： 保存后，我们进行本地发布： 123$ hexo clean$ hexo g$ hexo server 如下图：发布成功,这个时候我们打开浏览器，输入： 1http://localhost:4000/ 我们可以在浏览器端看到我们搭建好的博客和发布的文章：因为我这里使用了yilia主题，所以界面风格可能和大家的有所不同。如何更换主题，本文之后会详细介绍。 到了这里发布博客就已经完成了。但是毕竟我们目前发布的只有本机看得到，怎么让其他人看到我们写的博客呢？这时候我们来看看博客的部署。 我们只要在终端执行这样的命令即可： 12345$ hexo generate$ hexo deploy 或者可以简写为$ hexo d g 这样我们在浏览器中输入刚才我们创建的仓库对应的链接，例如： 1https://false7518.github.io 就可以在任何地方访问到我们的博客了。 主题更换 下载主题 1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 配置 首先我们切换到我们刚才创建的博客的目录下，这个文件夹主要用来进行博客的管理，看下目录下的详情。 yilia主题就在themes目录下了,_config.yml主要是主目录下的一些配置，很清晰，每个地方应该如何填写也很简单 修改hexo根目录下的 _config.yml ： theme: yilia 更新 12cd themes/yiliagit pull 主题配置文件在主题主目录下的_config.yml，请根据自己需要修改使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# Headermenu: 主页: / 随笔: /tags/随笔/# SubNavsubnav: github: &quot;#&quot; weibo: &quot;#&quot; rss: &quot;#&quot; zhihu: &quot;#&quot; #qq: &quot;#&quot; #weixin: &quot;#&quot; #jianshu: &quot;#&quot; #douban: &quot;#&quot; #segmentfault: &quot;#&quot; #bilibili: &quot;#&quot; #acfun: &quot;#&quot; #mail: &quot;mailto:litten225@qq.com&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: # Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: &apos;展开全文&apos;# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 请在需要打赏的文章的md文件头部，设置属性reward: true# 打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: &apos;谢谢你请我吃糖果&apos;# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # Miscellaneousbaidu_analytics: &apos;&apos;google_analytics: &apos;&apos;favicon: /favicon.png#你的头像urlavatar:#是否开启分享share_jia: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: false# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: &apos;#4d4d4d&apos; # 右滑板块背景 slider: &apos;linear-gradient(200deg,#a0cfe4,#e8c37e)&apos;# slider的设置slider: # 是否默认展开tags板块 showTags: false # 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: &apos;所有文章&apos; friends: &apos;友链&apos; aboutme: &apos;关于我&apos;friends: 友情链接1: http://localhost:4000/ 友情链接2: http://localhost:4000/ 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/aboutme: 很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家 配置之后重新发布，我们的博客主题就会替换成yilia主题了。替换其他主题的方法也是相同的，这里就不多说。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.aiwyt.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://www.aiwyt.com/tags/博客/"},{"name":"Github","slug":"Github","permalink":"http://www.aiwyt.com/tags/Github/"},{"name":"yilia","slug":"yilia","permalink":"http://www.aiwyt.com/tags/yilia/"}]},{"title":"Hello World","date":"2017-03-27T01:32:20.000Z","path":"/uncategorized/hello-world.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]