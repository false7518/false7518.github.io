[{"title":"理解iOS内存管理","date":"2017-04-20T02:47:27.000Z","path":"/uncategorized/理解iOS内存管理.html","text":"本文将介绍如何使用Objective-C和Cocoa进行内存管理。内存管理是程序设计中常见的资源管理(resource management)的一部分。每个计算机系统可供程序使用的资源都是有限的，包括内存、网络连接等。如果你不断的打开文件并且保持打开状态而从不关闭，最终将好近文件资源。任何人都不希望出现这种结果。 不是每个程序都会使用文件或网络连接，但都会消耗内存。每个C语言程序员都会遇到与内存有关的错误，这种错误是灾难性的。而使用Java和脚本语言的程序员则不需要考虑此类问题：这些语言的内存管理是自动进行的。另一方面我们必须确保在需要的时候分配内存，在程序运行结束时释放内存。如果我们只分配而不释放，就会导致内存泄漏(leak memory)：程序的内存占用量不断增加，最终会被耗尽并导致程序崩溃。 已用计数(Reference Count)是一个简单而有效的管理对象生命周期的方式，不管是Objective-C语言还是Swift语言，其内存管理方式都是基于引用计数的。本章将讲解这种内存管理方式的特点及注意事项。 对象生命周期正如现实世界中的生物一样，程序中的对象也是有生命周期的。对象的生命周期包括诞生(通过alloc或new方法实现)、生存(接收消息并执行操作)、交友(通过复合以及向方法传递参数)以及最终死去(被释放掉)。当生命周期结束时，它们的原材料(内存)将被回收，以供新的对象使用。 引用计数什么是引用计数，原理是什么？引用计数可以有效的管理对象生命周期。当我们创建一个新对象的时候，它的引用计数为1，当有一个新的指针指向这个对象时，我们将其引用计数加1，当某个指针不再指向这个对象时，我们将其引用计数减1，当对象的引用计数变为0时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。 当使用alloc、new方法或者通过copy(接收到该消息的对象会创建一个自身的副本)创建一个对象时，对象的引用计数会被设置为1。要增加对象的引用计数的值，可以对该对象使用retain。要减少的话，怎可以使用release方法。 当一个对象的引用计数为0即将销毁时，Objective-C会自动调用对象的dealloc方法。你可以在自己的对象中重写dealloc方法，这样就能释放掉已经分配的全部相关资源。一定不要直接调用dealloc方法，Objective-C会在需要销毁对象时自动调用它。 要获得引用计数的值，可以使用retainCount方法。 123- (id)retain;- (oneway void)release;- (NSUInteger)retainCount; retain方法返回一个id类型的值。通过这种方式，可以在接受其他消息的同事进行retain调用，增加对象引用计数值并要求对象完成某种操作。例如，[[car retain] setTire:tire atIndex:2];表示要求car对象保留其引用计数器的值加1并执行setTire操作。 由于引用计数简单有效，除了Objective-C语言外，微软的COM(Component Object Model)、C++11（C++11提供了基于引用计数的智能指针share_prt）等语言也提供了基于引用计数的内存管理方式，如下图所示。为了更形象一些，我们再来看一段Objective-C的代码。新建一个工程，因为现在默认的工程都开启了自动引用计数ARC(Automatic Reference Count)，我们先修改工程设置，给Appdelegate.m加上-fno-objc-arc的编译参数，如下图所示。这个参数可以启用手动内存管理引用计数的模式。然后，我们在中输入如下代码，可以通过 Log 看到相应的引用计数的变化。 12345678910111213- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSObject *object = [[NSObject alloc] init]; NSLog(@&quot;Reference Count = %u&quot;, [object retainCount]); NSObject *another = [object retain]; NSLog(@&quot;Reference Count = %u&quot;, [object retainCount]); [another release]; NSLog(@&quot;Reference Count = %u&quot;, [object retainCount]); [object release]; // 到这里时，object 的内存被释放了 return YES;&#125; 运行结果： 1Reference Count = 1 Reference Count = 2 Reference Count = 1 对 Linux 文件系统比较了解的同学可能发现，引用计数的这种管理方式类似于文件系统里面的硬链接。在 Linux 文件系统中，我们用 ln 命令可以创建一个硬链接（相当于我们这里的 retain)，当删除一个文件时（相当于我们这里的 release)，系统调用会检查文件的 link count 值，如果大于 1，则不会回收文件所占用的磁盘区域。直到最后一次删除前，系统发现 link count 值为 1，则系统才会执行直正的删除操作，把文件所占用的磁盘区域标记成未用 我们为什么需要引用计数从上面那个简单的例子中，我们还看不出来引用计数真正的用处。因为该对象的生命期只是在一个函数内，所以在真实的应用场景下，我们在函数内使用一个临时的对象，通常是不需要修改它的引用计数的，只需要在函数返回前将该对象销毁即可。 引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。我们举一个具体的例子： 假如对象 A 生成了一个对象 M，需要调用对象 B 的某一个方法，将对象 M 作为参数传递过去。在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，那么对象 A 就需要在对象 B 不再需要对象 M 的时候，将对象 M 销毁。但对象 B 可能只是临时用一下对象 M，也可能觉得对象 M 很重要，将它设置成自己的一个成员变量，那这种情况下，什么时候销毁对象 M 就成了一个难题。 对于这种情况，有一个暴力的做法，就是对象 A 在调用完对象 B 之后，马上就销毁参数对象 M，然后对象 B 需要将参数另外复制一份，生成另一个对象 M2，然后自己管理对象 M2 的生命期。但是这种做法有一个很大的问题，就是它带来了更多的内存申请、复制、释放的工作。本来一个可以复用的对象，因为不方便管理它的生命期，就简单的把它销毁，又重新构造一份一样的，实在太影响性能。如下图所示： 我们另外还有一种办法，就是对象 A 在构造完对象 M 之后，始终不销毁对象 M，由对象 B 来完成对象 M 的销毁工作。如果对象 B 需要长时间使用对象 M，它就不销毁它，如果只是临时用一下，则可以用完后马上销毁。这种做法看似很好地解决了对象复制的问题，但是它强烈依赖于 AB 两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于对象 M 的申请是在对象 A 中，释放在对象 B 中，使得它的内存管理代码分散在不同对象中，管理起来也非常费劲。如果这个时候情况再复杂一些，例如对象 B 需要再向对象 C 传递对象 M，那么这个对象在对象 C 中又不能让对象 C 管理。所以这种方式带来的复杂性更大，更不可取。 所以引用计数很好的解决了这个问题，在参数 M 的传递过程中，哪些对象需要长时间使用这个对象，就把它的引用计数加 1，使用完了之后再把引用计数减 1。所有对象都遵守这个规则的话，对象的生命期管理就可以完全交给引用计数了。我们也可以很方便地享受到共享对象带来的好处。 自动释放池Cocoa中有一个自动释放池(autorelease pool)的概念。你可能已经见过@autoreleasepool或NSAutoreleasePool。现在我们来看看自动释放池究竟是怎么一回事。 从名称上来推测，他大概是一个用来存放对象的池子，并且能够自动释放。 NSObject类提供了一个叫autorelease的方法： 1- (id)autorelease; 该方法预先设定了一条会在未来某个时间放松的release消息，其返回值是接受这条消息的对象。这一特性与retain消息采用了相同的技术。党给一个对象发送autorelease消息时，实际上是讲该对象添加到了自动释放池中。当自动释放池被销毁时，会向该池中的所有对象发送release消息。 现在我们可以编写一个能够很好的管理内存的description方法。 2你现在只要编写一行这样的代码就够了： 1NSLog(@&quot;%@&quot;,[someObject description]); 因为description方法首先创建了一个新的字符串对象，然后自动释放该对象，最后将其返回给NSLog()函数，所以内存管理问题至此得到了圆满的解决。由于description方法中的字符串对象是自动释放的，该对象暂时被放入了当前活动的自动释放池中，等到调用NSLog()函数的代码结束以后，自动释放池会被自动销毁。 自动释放池什么时候销毁自动释放池什么时候销毁，并向其所包含的对象发送release消息？还有自动释放池应该什么时候创建？其实有两种方法可以创建一个自动释放池。 通过@autoreleasepool关键字 通过NSAutoreleasePool对象 在我们一直使用的Foundation工具集中，创建和销毁自动释放池已经由@autoreleasepool关键字完成。当你使用@autoreleasepool{}时，所有在花括号里的代码都会被放入这个新池子中。如果你的程序运算是内存密集型的，你可以使用这种自动释放池。 有一点需要记住，任何在花括号里定义的变量在花括号外无法使用。 第二种更加明确地方法就是使用NSAutoreleasePool对象。如果你使用这个方法，创建和释放NSAutoreleasePool对象之间的代码就会使用这个新的池子。 123NSAutoreleasePool *pool = [NSAutoreleasePool new];...[pool release]; 创建了一个自动释放池后，该池子就会自动变成为活动的池子。释放该池后，其保留计数器的值归0，然后该池被销毁。在销毁的过程中，该池将释放其包含的所有对象。 那么你应该使用哪一种方法呢？推荐使用关键字方法。它比对象方法更快。因为Objective-C语言创建和释放内存的能力远在我们之上。 使用APPKit时，Cocoa定期自动为你创建和销毁自动释放池。通常实在程序处理完当前事件以后执行这些操作。你可以使用任意树木的自动释放池对象，当不再使用它们时，自动释放池将自动为你清理这些对象。 自动释放池的工作流程下面我将通过代码，展示下自动释放池的工作流程。 main()函数如下所示： 123456789101112131415161718192021222324252627282930313233343536int main(int argc,const char* argv[])&#123; //首先，我们创建了一个自动释放池： NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; //现在每次向对象发送autorelease消息，该对象都会被添加到这个自动释放池中， RetainTracker *tracker = [RetainTracker new]; //count:1 //这时创建了一个新的tracker对象，因为他在创建时接收了一条new消息，所以计数器值为1 [tracker retain]; //count:2 //接下来我们保留对象，于是该对象计数器值增加到2 [tracker autorelease]; //count:still 2 //然后该对象被自动释放，但是其引用计数值仍保持不变，依旧是2. [tracker release]; //count:1 //之后释放该对象，抵消之前的retain操作 NSLog(@&quot;releasing pool&quot;); [pool release]; //gets nuked,sends release to tracker //现在我们销毁该释放池。因该释放池奖杯销毁掉，其dealloc方法被调用。 //使用@autoreleasepool也能达到同样的目的，不过它并不需要分配或销毁自动释放池对象。 @autoreleasepool &#123; RetainTracker *tracker2 = [RetainTracker new]; //count:1 [tracker2 retain]; //count:2 [tracker2 autorelease]; //count:still 2 [tracker2 release]; //count:1 NSLog(@&quot;auto releasing pool&quot;); &#125; return(0);&#125; //main 不要向已经释放的对象发送消息有些同学想测试当对象释放时，其 retainCount 是否变成了 0，他们的试验代码如下： 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSObject *object = [[NSObject alloc] init]; NSLog(@&quot;Reference Count = %u&quot;, [object retainCount]); [object release]; NSLog(@&quot;Reference Count = %u&quot;, [object retainCount]); return YES;&#125; 但是，如果你真的这么实验，你得到的输出结果可能是以下这样： 1Reference Count = 1 Reference Count = 1 我们注意到，最后一次输出，引用计数并没有变成 0。这是为什么呢？因为该对象的内存已经被回收，而我们向一个已经被回收的对象发了一个 retainCount 消息，所以它的输出结果应该是不确定的，如果该对象所占的内存被复用了，那么就有可能造成程序异常崩溃。 那为什么在这个对象被回收之后，这个不确定的值是 1 而不是 0 呢？这是因为当最后一次执行 release 时，系统知道马上就要回收内存了，就没有必要再将 retainCount 减 1 了，因为不管减不减 1，该对象都肯定会被回收，而对象被回收后，它的所有的内存区域，包括 retainCount 值也变得没有意义。不将这个值从 1 变成 0，可以减少一次内存的写操作，加速对象的回收。 拿我们之前提到的 Linux 文件系统举列，Linux 文件系统下删除一个文件，也不是真正的将文件的磁盘区域进行抹除操作，而只是删除该文件的索引节点号。这也和引用计数的内存回收方式类似，即回收时只做标记，并不抹除相关的数据。 循环引用（Reference Cycle）问题引用计数这种管理内存的方式虽然很简单，但是有一个比较大的瑕疵，即它不能很好的解决循环引用问题。如下图所示：对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁与依赖于对象 A 的销毁，这样就造成了我们称之为循环引用（Reference Cycle）的问题，这两个对象即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放 不止两对象存在循环引用问题，多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，环越大就越难被发现。下图是 4 个对象形成的循环引用问题。 解决循环引用问题主要有两个办法，第一个办法是我明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。如下图所示： 不过，主动断开循环引用这种操作依赖于程序员自己手工显式地控制，相当于回到了以前 “谁申请谁释放” 的内存管理年代，它依赖于程序员自己有能力发现循环引用并且知道在什么时机断开循环引用回收内存（这通常与具体的业务逻辑相关），所以这种解决方法并不常用，更常见的办法是使用弱引用 (weak reference) 的办法。 弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。在 iOS 开发中，弱引用通常在 delegate 模式中使用。举个例子来说，两个 ViewController A 和 B，ViewController A 需要弹出 ViewController B，让用户输入一些内容，当用户输入完成后，ViewController B 需要将内容返回给 ViewController A。这个时候，View Controller 的 delegate 成员变量通常是一个弱引用，以避免两个 ViewController 相互引用对方造成循环引用问题，如下所示： 使用 Xcode 检测循环引用Xcode 的 Instruments 工具集可以很方便的检测循环引用。为了测试效果，我们在一个测试用的 ViewController 中填入以下代码，该代码中的firstArray 和 secondArray 相互引用了对方，构成了循环引用。 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableArray *firstArray = [NSMutableArray array]; NSMutableArray *secondArray = [NSMutableArray array]; [firstArray addObject:secondArray]; [secondArray addObject:firstArray]; &#125; 在 Xcode 的菜单栏选择：Product -&gt; Profile，然后选择 “Leaks”，再点击右下角的”Profile” 按钮开始检测。如下图 这个时候 iOS 模拟器会运行起来，我们在模拟器里进行一些界面的切换操作。稍等几秒钟，就可以看到 Instruments 检测到了我们的这次循环引用。Instruments 中会用一条红色的条来表示一次内存泄漏的产生。如下图所示： 我们可以切换到 Leaks 这栏，点击”Cycles &amp; Roots”，就可以看到以图形方式显示出来的循环引用。这样我们就可以非常方便地找到循环引用的对象了。 使用ARCAutomatic Reference Count自动引用技术(Automatic Reference Count，简称ARC)，是苹果在WWDC2011年大会上提出的用于内存管理的技术。ARC技术直到今天，仍然被不少人误解。误解主要分为两类：1、对于ARC的疑虑；2、对于ARC的盲目依赖。 第一类的人主要是经历过手工管理引用计数(Manual Reference Count,简称MRC)时代的老一代iOS程序员,他们主要是对ARC技术有怀疑,不敢用。 第二类的人主要是2011年以后,一开始就从ARC开始学习的新的iOS开发者们,他们有些人完全不知道引用计数为何物,对ARC有很强的依赖,但是不知道ARC内部的原理,过于依赖ARC使得他们遇到需要与Core Foundation类打交道,以及循环引用问题时,显得一筹莫展。 对于ARC的疑虑我们来先说说第一类:老一代iOS程序员对于ARC的疑虑,经过和他们沟通,我了解到他们对于ARC的疑虑主要在以下几点: 担心这个技术方案不靠谱。苹果大多数时候的技术方案都是比较靠谱的,但也有一些技术方案有很多“坑”,例如storyboard。 原有的项目在非ARC环境下运行良好,担心迁移成本或引入新的问题。原有的第三方库可能也没有兼容ARC,担心有迁移成本。 苹果以前手工管理内存需要非常小心,稍微不注意应用程序就崩溃了。有过这段经历的iOS开发老手,心理上还是觉得自己手工管理内存更踏实一些。 使用ARC需要了解ARC的一些细节,还需要引入_bridge等新的关键字,学习成本还是有的。 以为ARC只能支持iOS5.0以上,这是非常大的误解。 对于上面提到5点问题,我认为相应的回答如下: ARC是WWDC2011大会时提出的技术,离现在已经很多年了,而且苹果现在将MacOS上的垃圾回收机制废弃(Deprecated),采用ARC替代,无疑证明了ARC是成熟的了。 确实有一些迁移成本,但苹果在Xcode中专门集成了迁移工具,成本已经非常小了。如下图所示就是Xcode集成的将非ARC工程转换成ARC工程的工具。另外,为了兼容第三方的非ARC开源库,你也可以在工程中随意使用编译参数-fno-objc-arc,这个参数允许对部分文件关闭ARC。 手工管理内存虽然踏实,但是很容易发生泄露。常常在开发完成后,需要使用Instruments来检测泄露。但用了ARC后,基本不会出现泄露了,我在开发iPhone客户端时,由于使用了ARC,花三个月开发完的应用,用Instruments检测后,没有发现任何内存泄漏问题。这在没有使用ARC的工程中是不可想象的。 ARC确实有学习成本,但是非常值得学习,学成后能省不少开发精力。 虽然ARC是与iOS5一同推出,但是由于ARC的实现机制是在编译期完成,所以使用ARC之后应用仍然可以支持iOS4.3。稍微需要注意的是,如果要在ARC开启的情况下支持iOS4.3,需要将weak关键字换成__unsafe_unretained。 所以我希望大家都能在项目中使用ARC,一旦你感受到它带来的好处,你就离不开它了。它也能让你从繁琐的内存管理代码中解放出来,用更多精力关注于代码结构、设计模式而不是底层的内存管理。 对于ARC的盲目依赖ARC能够解决iOS开发中90%的内存管理问题,但是另外还有10%的内存管理,是需要开发者自己处理的,这主要就是与底层Core Foundation对象交互的那部分,底层的Core Foundation对象由于不在ARC的管理下,所以需要自己维护这些对象的引用计数。 对于ARC盲目依赖的iOS新人们,由于不知道引用计数,他们的问题主要体现在: 过度使用block之后,无法解决循环引用问题。 遇到底层Core Foundation对象,需要自己手工管理它们的引用计数时,显得一筹莫展。 Core Foundation对象的内存管理下面我们就来简单介绍一下对底层Core Foundation对象的内存管理。底层的Core Foundation对象,大多数以XxxCreateWithXxx这样的方式创建,例如: 1234567//创建一个CFStringRef对象CFStringRef str= CFStringCreateWithCString(kCFAllocatorDefault,“hello world&quot;, kCFStringEncodingUTF8// 创建一个CTFontRef 对象CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;,␣fontSize,␣NULL); 对于这些对象的引用计数的修改,要相应地使用CFRetain和CFRelease方法。如下所示: 123456789//创建一个CTFontRef对象CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL);//引用计数加1CFRetain(fontRef);//引用计数减1CFRelease(fontRef); 对于CFRetain和CFRelease两种方法,读者可以直观地认为,它们与Objective-C对象的retain和release方法等价。 所以对于底层Core Foundation对象,我们只需要延续以前手工管理引用计数的办法即可。 除此之外,还有另外一个问题需要解决。在ARC下,我们有时需要将一个Core Foundation对象转换成一个Objective-C对象,这个时候我们需要告诉编译器,转换过程中的引用计数需要做如何的调整。这就引入了bridge相关的关键字,以下是这些关键字的说明: __bridge:只做类型转换,不修改相关对象的引用计数,原来的Core Foundation对象在不用时,需要调用CFRelease方法。 __bridge_retained:类型转换后,将相关对象的引用计数加1,原来的Core Foundation对象在不用时,需要调用CFRelease方法。 __bridge_transfer:类型转换后,将该对象的引用计数交给ARC管理,Core Foundation对象在不用时,不再需要调用CFRelease方法。 我们根据具体的业务逻辑,合理使用上面的三种转换关键字,就可以解决Core Foundation对象与Objective-C对象相对转换的问题了。","tags":[]},{"title":"iOS获取时间---当天、前一天、下一天","date":"2017-04-19T10:09:33.000Z","path":"/uncategorized/iOS获取时间-当天、前一天、下一天.html","text":"1234567891011121314151617181920212223242526272829303132333435363738#pragma mark - 获取时间，当天，前一天，下一天- (NSString *)getDateForUrl:(NSDate *)date&#123; NSDate *early = [date earlierDate:date]; NSDate *ed = [early earlierDate:date]; NSLog(@&quot;early%@&quot;,early); NSLog(@&quot;ed%@&quot;,ed); NSString *str = [[NSString alloc] initWithFormat:@&quot;%@&quot;,date]; NSArray *array1 = [str componentsSeparatedByString:@&quot; &quot;]; NSString *subStr1 = [array1 objectAtIndex:0]; NSArray *array2 = [subStr1 componentsSeparatedByString:@&quot;-&quot;]; NSString *subStr2 = [array2 componentsJoinedByString:nil]; NSLog(@&quot;%@&quot;,subStr2); return subStr2;&#125;- (NSDate *)customEarlyDate:(NSDate *)anotherDate&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSDateComponents *comps; comps = [calendar components:(NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit) fromDate:nil]; [comps setHour:-24]; //+24表示获取下一天的date，-24表示获取前一天的date； [comps setMinute:0]; [comps setSecond:0]; NSDate *nowDate = [calendar dateByAddingComponents:comps toDate:anotherDate options:0]; //showDate表示某天的date，nowDate表示showDate的前一天或下一天的date return nowDate;&#125;- (NSDate *)customLatterDate:(NSDate *)anotherDate&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSDateComponents *comps; comps = [calendar components:(NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit) fromDate:nil]; [comps setHour:+24]; //+24表示获取下一天的date，-24表示获取前一天的date； [comps setMinute:0]; [comps setSecond:0]; NSDate *nowDate = [calendar dateByAddingComponents:comps toDate:anotherDate options:0]; //showDate表示某天的date，nowDate表示showDate的前一天或下一天的date return nowDate;&#125;","tags":[]},{"title":"如何在iOS中播放，录制和编辑视频","date":"2017-04-19T08:52:23.000Z","path":"/uncategorized/如何在iOS中播放，录制和编辑视频.html","text":"录制视频，编辑并播放在日常生活中是一个很常用的功能。但是令人惊讶的是，这方面的技术帖子，文章并不好找。这个可能是因为学习iOS中录制和编辑的技术 — AVFoundation — 是非常困难的。本文，就简单讲述下，在iOS中如何进行视频的录制，播放，编辑。 在本文中，我们将为您提供AVFoundation API的实践经验，以便您可以在自己的应用程序中开始使用它们。您将学习如何： 从媒体库中选择并播放视频 录制视频并将视频保存到媒体库 将多个视频合并成一个组合的视频，并添加自定义背景音乐 入门让我们开始创建一个简单的应用程序，让您播放和录制视频并将其保存到文件中。 启动Xcode并使用iOS \\ Application \\ Single View Application模板创建一个新项目。为项目名称输入“VideoPlayRecord”，为设备系列选择iPhone，确保选中“使用故事板”和“使用自动参考计数”选项，并将项目保存到您选择的位置。 接下来，为您的项目添加一些必要的框架。 在左侧栏的“项目导航器”窗格中选择项目的根，以在中央窗格中显示项目信息。如果未选择项目目标，请选择它，然后切换到“构建阶段”选项卡。 现在点击“使用库链接二进制”部分的三角形来展开它。在这里，您可以向项目添加其他库/框架。 单击（+）按钮添加框架。您可以通过命令单击每个项目来选择打开的对话框中的多个项目。将以下框架添加到您的项目中： 资产图书馆 AVFoundation CoreMedia 媒体播放器 MobileCoreServies QuartzCore 在这个项目中，您将创建一个包含四个屏幕的应用程序。第一个将只有三个按钮，将允许您导航到以下三个屏幕： 视频播放 视频记录 视频合并 得到你的故事直在主窗口中选择MainStoryboard.storyboard以查看视图控制器。您需要将此视图控制器嵌入到导航控制器中，因为应用中将有多个屏幕。 要做到这一点，首先单击视图控制器给它焦点，然后从菜单中单击选择编辑器\\嵌入\\导航控制器。视图控制器现在与导航控制器相隔。 现在，从对象库中拖动三个UIButtons（右侧边栏的下半部分 - 如果对象库未被选中，则是第三个选项卡）到视图控制器。一旦您将其放在视图中，您可以按照以下方式设置按钮的标题： 选择和播放视频 录制和保存视频 合并视频 您可以通过点击按钮来选择每个按钮来设置标题，然后在属性检查器中编辑按钮的标题属性，这是右侧栏的上半部分的第四个选项卡。 接下来，为通过这些按钮显示的视图设置三个视图控制器。通过使用iOS \\ Cocoa Touch \\ UIViewController子类模板创建三个UIViewController子类对象来执行此操作。命名新类PlayVideoViewController，RecordVideoViewController和MergeVideoViewController。当您使用故事板时，请确保您取消选中“为每个类使用XIB用户界面”选项。 现在切换回MainStoryboard.storyboard并将三个UIViewControllers从对象库拖到你的故事板上。依次选择每个视图控制器对象，并切换到身份检查器（右侧栏的上半部分的第三个选项卡），以按如下方式为每个视图控制器设置类： PlayVideoViewController RecordVideoViewController MergeVideoViewController 现在你必须将所有这些东西挂在一起。您将通过创建一个从每个按钮切换到要加载的新视图控制器来执行此操作。 依次选择每个按钮，确保“连接检查器”（右侧栏的上半部分的第六个选项卡）已打开，并从“推送”连接器拖到相关视图控制器。 完成后，您的故事板应该类似于下面的屏幕： 很好，你已经设置了基本的UI！构建应用程序并运行它，以确保三个按钮按预期工作，每个按钮都进入辅助屏幕。 如果你对故事板和如何设置它们感到困惑，别担心！有一个教程。查看iOS 5教程系列中的开始故事板。 现在，您的UI正在运行，现在是创建这些辅助屏幕并给出一些实质内容的时候了！ 选择和播放视频导入头文件 12#import &lt;MobileCoreServices / UTCoreTypes.h&gt; #import &lt;MediaPlayer / MediaPlayer.h&gt; 添加代理协议，将以下代码添加到#import语句下方的@interface行的末尾： 1&lt;UIImagePickerControllerDelegate，UINavigationControllerDelegate&gt; 这将设置PlayVideoViewController作为UIImagePickerController和UINavigationController的委托，以便您可以在您的类中使用UIImagePickerController。具体来说，您将使用它来浏览照片库中的视频。 苹果提供的这个UIImagePickerController类是什么？它提供了一个基本的，可定制的用户界面，用于拍摄和录制电影。它还为新捕获的媒体提供了一些简单的编辑功能。如果您不需要完全定制的UI，通常最好使用图像选择器控制器从媒体库中选择音频和视频文件。要浏览媒体，您需要打开一个UIImagePickerController的实例作为弹出视图。 1234567891011121314151617181920//打开UIImagePickerController - （BOOL ） startMediaBrowserFromViewController ：（ UIViewController * ） controller usingDelegate ：（id ） delegate &#123; // 1 - 验证 if （（[ UIImagePickerController isSourceTypeAvailable ： UIImagePickerControllerSourceTypeSavedPhotosAlbum ] == NO ） || （ delegate == nil ） || （ controller == nil ）） &#123; return NO ; &#125; // 2 - 获取图像选择器 UIImagePickerController * mediaUI = [ [ UIImagePickerController alloc ] init ] ; mediaUI.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum; mediaUI.mediaTypes = [ [ NSArray alloc ] initWithObjects ： （NSString * ） kUTTypeMovie，nil ] ; //隐藏用于移动和缩放图片的控件，或 //修剪动画。要显示控件，请使用YES。 mediaUI.allowsEditing = YES ; mediaUI.delegate = delegate; // 3 - 显示图像选择器 [ controller presentModalViewController ： mediaUI animated ：YES ] ; 返回 YES ;&#125; 在上述代码中，您将执行以下操作： 1、检查UIImagePickerControllerSourceTypeSavedPhotosAlbum（定义的源）是否在设备上可用。当您使用UIImagePickerController来挑选媒体时，此检查是必不可少的。如果您不这样做，您可能会尝试从不存在的媒体库中挑选媒体，导致崩溃或其他意外问题。 2、如果您想要的源可用，则创建一个新的UIImagePickerController对象并设置其源和媒体类型。只有“kUTTypeMovie”包含在mediaTypes数组中，因为您只需要视频。您可以在数组中包含“kUTTypeImage”来选择图像。 3、最后，您将UIImagePickerController呈现为模态视图控制器。 如果您的媒体库中有视频，则您可以在第一个屏幕上点击“选择和播放视频”按钮，然后点击第二个“播放视频”按钮，看到它们与以下屏幕截图相似。屏幕。 注意：如果您在模拟器上运行此项目，则无法捕获视频。此外，您需要找出一种手动将视频添加到媒体库的方法。换句话说，我建议你在设备上测试这个项目！ 看到视频列表后，选择一个。您将被带到另一个显示视频的屏幕。点击“选择”按钮在这里实际选择视频。 如果您点击“选择”，除了应用程序返回播放视频屏幕外没有任何反应！这是因为您没有实现任何委托方法来处理在显示图像选择器时执行的操作。 UIImagePickerController有一个委托回调方法，可以在选择媒体时执行。实现通过添加以下代码的结束该方法PlayVideoViewController.m： 1234567891011121314151617- （void ） imagePickerController ：（ UIImagePickerController * ） picker didFinishPickingMediaWithInfo ：（NSDictionary * ） info &#123; // 1 - 获取媒体类型 NSString * mediaType = [ info objectForKey ： UIImagePickerControllerMediaType ] ; // 2 - 关闭图像选择器 [ self dismissModalViewControllerAnimated ：NO ] ; //处理电影捕获 如果 （ CFStringCompare （（ __bridge_retained CFStringRef ） mediaType的，kUTTypeMovie，0 ） == kCFCompareEqualTo ） &#123; // 3 -播放视频 MPMoviePlayerViewController * theMovie = [ [ MPMoviePlayerViewController的alloc ] initWithContentURL ：[信息objectForKey ： UIImagePickerControllerMediaURL ] ] ; [自presentMoviePlayerViewControllerAnimated ： theMovie ] ; // 4 -注册为再现完毕通知 [ [ NSNotificationCenter defaultCenter ]的addObserver ：自选择器：@selector （ myMovieFinishedCallback ：） 名称： MPMoviePlayerPlaybackDidFinishNotification对象： theMovie ] ; &#125; &#125; @selector （ myMovieFinishedCallback ：）名称： MPMoviePlayerPlaybackDidFinishNotification对象： theMovie ] ; &#125; &#125; @selector （ myMovieFinishedCallback ：）名称： MPMoviePlayerPlaybackDidFinishNotification对象： theMovie ] ; &#125; &#125; 上述代码执行以下操作： 获取媒体类型，以便稍后验证所选媒体是视频。 关闭图像选择器，使其不再显示在屏幕上。 验证所选媒体是否为视频，然后创建MPMoviePlayerViewController的实例来播放。 添加一个回调方法，该方法将在电影完成播放后执行。 所述myMovieFinishedCallback：在步骤＃4中引用的方法需要实现。下面的代码添加到年底PlayVideoViewController.m： 1234567//电影完成后，释放控制器。- （void ） myMovieFinishedCallback ：（NSNotification * ） aNotification &#123; [ self dismissMoviePlayerViewControllerAnimated ] ; 的MPMoviePlayerController * theMovie = [ aNotification对象] ; [ [ NSNotificationCenter defaultCenter ] removeObserver ： self 名： MPMoviePlayerPlaybackDidFinishNotification对象： theMovie ] ;&#125; 最后一件事是为用户点击“取消”而不是选择视频添加一个处理程序。在ImagePickerController下面添加以下代码：didFinishPickingMediaWithInfo： 1234//为了响应用户点击取消。- （void ） imagePickerControllerDidCancel ：（ UIImagePickerController * ） picker &#123; [ self dismissModalViewControllerAnimated ： YES ] ;&#125; 如果用户取消操作，图像选择器将被取消。 编译并运行您的项目。按“选择和播放视频”按钮，然后按“播放视频”按钮，最后从列表中选择一个视频。您应该可以看到在媒体播放器播放的视频。 录制和保存视频现在，您有视频播放功能，现在是使用设备的相机录制视频并将其保存到媒体库的时候了。切换回故事板，并执行以下操作： 添加一个名为“录制视频”的新按钮到录像视频控制器。 如前所述，切换到助手编辑器模式，并将“录制视频”按钮连接到名为recordAndPlay的操作：。 获取编码的时间！用以下内容替换RecordVideoViewController.h的内容： 123456789101112#import &lt;MediaPlayer / MediaPlayer.h&gt; #import &lt;MobileCoreServices / UTCoreTypes.h&gt; #import &lt;AssetsLibrary / AssetsLibrary.h&gt; @interface RecordVideoViewController ： UIViewController - （ IBAction ） recordAndPlay ：（id ） sender;- （BOOL ） startCameraControllerFromViewController ：（ UIViewController * ）控制器 usingDelegate ：（id ） delegate;- （void ） video : (（NSString * ） videoPath didFinishSavingWithError ：（NSError * ） error contextInfo ：（void * ） contextInfo; @结束 您可能已经注意到：其中一些与您在PlayVideoViewController中所做的相似。至于没有的位： AssetsLibrary.h导入可以访问照片应用程序控件下的视频和照片。当您将视频保存到已保存的照片库时，您需要访问AssetsLibrary框架。 资产库包括已保存的照片相册中的媒体，来自iTunes的媒体以及直接导入设备的媒体。您可以使用AssetsLibrary检索所有资产组的列表，并将图像和视频保存到已保存的照片相册中。 其他新产品视频：didFinishSavingWithError：contextInfo： 。顾名思义，该方法在将视频保存到资产/照片库后执行。 切换到RecordVideoViewController.m并将以下内容添加到recordAndPlay：： 1[ self startCameraControllerFromViewController ： self usingDelegate ： self ] ; 你再次在熟悉的地区。该代码简单地调用startCameraControllerFromViewController：usingDelegate：当“录制视频”按钮被点击时。当然，这意味着你应该添加下一个方法的实现。将以下代码添加到文件的末尾（但在最后的@end之前）： 123456789101112131415161718192021- （BOOL ） startCameraControllerFromViewController ：（ UIViewController * ）控制器 usingDelegate ：（id ） delegate &#123; // 1 - Validatt if if （（[ UIImagePickerController isSourceTypeAvailable ： UIImagePickerControllerSourceTypeCamera ] == NO ） || （ delegate == nil ） || （ controller == nil ）） &#123; return NO ; &#125; // 2 - 获取图像选择器 UIImagePickerController * cameraUI = [ [ UIImagePickerController alloc ] init ] ; cameraUI.sourceType = UIImagePickerControllerSourceTypeCamera; //显示允许用户选择影片捕获的 控件cameraUI.mediaTypes = [ [ NSArray alloc ] initWithObjects ：（NSString * ） kUTTypeMovie，nil ] ; //隐藏用于移动和缩放图片的控件，或 //修剪动画。要显示控件，请使用YES。 cameraUI.allowsEditing = NO ; cameraUI.delegate = delegate; // 3 - 显示图像选择器 [ controller presentModalViewController ： cameraUI animated ： YES ] ; 返回 YES ;&#125; 在上面的代码中，您检查“UIImagePickerControllerSourceTypeCamera”而不是“UIImagePickerControllerSourceTypeSavedPhotosAlbum”，因为您要使用相机。其余的代码与以前使用的代码大致相同。 构建并运行你的代码，看看你到目前为止。 转到记录屏幕，然后按“录制视频”按钮。相机界面打开，而不是照片库。通过点击屏幕底部的红色记录按钮开始录制视频，完成录制后再次点击。 这个视频看起来更令人兴奋。我不能在这里张贴，但是有一个很好的宝贝就在屏幕外！只是开玩笑，但是当您看到自己的设备运行时更令人兴奋。：] 当您进入下一个屏幕时，您可以选择使用录制的视频或重新拍摄视频。如果您选择“使用”，您会注意到没有任何反应 - 这是因为您猜测到，没有实现回调方法。您需要回调方法将录制的视频保存到媒体库。 为了实现回调方法，下面的代码添加到年底RecordVideoViewController.m： 1234567891011121314151617181920- （void ） imagePickerController ：（ UIImagePickerController * ） picker didFinishPickingMediaWithInfo ：（NSDictionary * ） info &#123; NSString * mediaType = [ info objectForKey ： UIImagePickerControllerMediaType ] ; [ self dismissModalViewControllerAnimated ：NO ] ; //处理电影捕获 if （ CFStringCompare （（ __bridge_retained CFStringRef ） mediaType，kUTTypeMovie，0 ） == kCFCompareEqualTo ） &#123; NSString * moviePath = [ [ info objectForKey ： UIImagePickerControllerMediaURL ] path ] ; 如果 （ UIVideoAtPathIsCompatibleWithSavedPhotosAlbum （ moviePath ）） &#123; UISaveVideoAtPathToSavedPhotosAlbum （ moviePath，自我， @selector （视频： didFinishSavingWithError ： contextInfo ：），零） ; nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; &#125; else &#123; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Video Saved”消息：@ “保存到相册” 委托： self cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; &#125; &#125; 在上面的代码中，imagePickerController：didFinishPickingMediaWithInfo：给你一个moviePath。您验证电影可以保存到设备的相册，如果是这样保存。 UISaveVideoAtPathToSavedPhotosAlbum是SDK提供的将视频保存到照片相册的默认方式。作为参数，你通过这两个被保存到该视频的路径，以及一个回调方法，将通知您的保存操作的状态。 构建代码并运行它。录制视频并选择“使用”。如果弹出“视频保存”按钮，则您的视频已成功保存到照片库。 AVFoundation简介现在，您的视频播放和录制已启动并运行，让我们进一步复杂一点：AVFoundation。 自iOS 4.0以来，iOS SDK在AVFoundation框架中提供了许多视频编辑API。使用这些API，您可以将任何种类的CGAffineTransform应用于视频，并将多个视频和音频文件合并到一个视频中。 本教程的最后几节将引导您将两个视频合并为单个视频并添加背景音轨。 在进入代码之前，先来讨论一些理论。 AVAsset这是一个抽象类，表示定时的视听媒体，如视频和音频。每个资产包含旨在一起呈现或处理的每个轨道的集合，每个轨道均包含但不限于音频，视频，文本，隐藏字幕和字幕。 AVAsset对象定义构成资产的轨道的集合属性。轨道由AVAssetTrack的实例表示。 在典型的简单情况下，一个轨道表示音频分量，另一个表示视频分量; 在复杂的组合中，可能存在多个重叠的音频和视频轨道。您将代表要合并为AVAsset对象的视频和音频文件。 AVCompositionAVComposition对象以自定义的时间排列方式组合来自多个基于文件的源的媒体数据，以便一起呈现或处理它们。无论容器类型如何，所有基于文件的视听资产均可合并。 在其顶层，AVComposition是一个轨道的集合，每个轨道根据时间线呈现特定类型的媒体，如音频或视频。每个曲目由AVCompositionTrack的一个实例表示。 AVMutableComposition和AVMutableCompositionTrackAVMutableComposition和AVMutableCompositionTrack也提供了构建组合的高级界面。这些对象提供插入，移除和缩放操作，而无需直接操纵组合轨道的轨道段数组。 AVMutableComposition和AVMutableCompositionTrack使用更高级的结构，如AVAsset和AVAssetTrack。这意味着客户端可以使用与创建的候选来源相同的引用，以便在包含在组合中之前对其进行检查或预览。 简而言之，您有一个AVMutableComposition，您可以向其添加多个AVMutableCompositionTrack实例。每个AVMutableCompositionTrack将有一个单独的媒体资源。 和休息为了将CGAffineTransform应用于曲目，您将使用AVVideoCompositionInstruction和AVVideoComposition。AVVideoCompositionInstruction对象表示由合成器执行的操作。该对象包含多个AVMutableVideoCompositionLayerInstruction对象。 您使用AVVideoCompositionLayerInstruction对象来修改变换和不透明度斜坡以应用于AV组合中的给定轨迹。AVMutableVideoCompositionLayerInstruction是AVVideoCompositionLayerInstruction的可变子类。 AVVideoComposition对象维护一组指令来执行其组合，并且AVMutableVideoComposition对象表示可变视频构图。 结论 您有一个主AVMutableComposition对象包含多个AVMutableCompositionTrack实例。每条轨道代表资产。 您有AVMutableVideoComposition对象包含多个AVMutableVideoCompositionInstructions。 每个AVMutableVideoCompositionInstruction包含多个AVMutableVideoCompositionLayerInstruction实例。 每层指令用于将特定的变换应用于给定的轨道。 知道了吗 在您下载项目示例代码之前，最终将进行测试。;] 现在你至少听说过你将用来合并媒体的所有主要对象。这可能有点混乱，但是当你编写一些代码时，事情会变得更加清晰。我承诺！ 合并视频现在把这个理论用了！打开MainStoryboard.storyboard并选择Merge Video View Controller。将四个按钮添加到屏幕，并将其命名如下： 负载资产1 负载资产2 加载音频 合并和保存视频 切换到助手编辑器模式，并将您的四个按钮连接到以下操作： loadAssetOne： loadAssetTwo： loadAudio： mergeAndSave： 最后的结果应该是这样的： 现在切换到MergeVideoViewController.h并将其内容替换为： 1234567891011121314151617181920212223#import &lt;AVFoundation / AVFoundation.h&gt; #import &lt;CoreMedia / CoreMedia.h&gt; #import &lt;MobileCoreServices / UTCoreTypes.h&gt; #import &lt;AssetsLibrary / AssetsLibrary.h&gt; #import &lt;MediaPlayer / MediaPlayer.h&gt; @interface MergeVideoViewController ： UIViewController &#123; BOOL isSelectingAssetOne;&#125; @property （ nonatomic，strong ） AVAsset * firstAsset;@property （ nonatomic，strong ） AVAsset * secondAsset;@property （ nonatomic，strong ） AVAsset * audioAsset;@property （弱，非原子） IBOutlet UIActivityIndi​​catorView * activityView; - （ IBAction ） loadAssetOne ：（id ） sender;- （ IBAction ） loadAssetTwo ：（id ） sender;- （ IBAction ） loadAudio ：（id ） sender;- （ IBAction ） mergeAndSave ：（id ） sender;- （BOOL ） startMediaBrowserFromViewController ：（ UIViewController * ） controller usingDelegate ：（id ）代表;- （void ） exportDidFinish ：（ AVAssetExportSession * ） session; @结束 以上大部分应该是熟悉的。有几个新的属性，但它们主要是保留对您添加的资产的引用，以创建最终合并的视频。除了资产之外，还有一个活动指标，当应用程序合并文件时会显示，因为可能需要一些时间来完成该过程。 要合成上面添加的属性，请切换到MergeVideoViewController.m，并在文件顶部添加以下内容，位于@implementation行之下： 12@synthesize firstAsset，secondAsset，audioAsset;@synthesize activityView; 然后，将以下内容添加到loadAssetOne中： 12345678if （[ UIImagePickerController isSourceTypeAvailable ： UIImagePickerControllerSourceTypeSavedPhotosAlbum ] == NO ） &#123; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Error” message ：@ “No saved Album Found” delegate ：nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; &#125; else &#123; isSelectingAssetOne = TRUE; [ self startMediaBrowserFromViewController ： self usingDelegate ： self ] ; &#125; 将此代码添加到loadAssetTwo中： 12345678if （[ UIImagePickerController isSourceTypeAvailable ： UIImagePickerControllerSourceTypeSavedPhotosAlbum ] == NO ） &#123; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Error” message ：@ “No saved Album Found” delegate ：nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ;&#125; else &#123; isSelectingAssetOne = FALSE; [ self startMediaBrowserFromViewController ： self usingDelegate ： self ] ; &#125; 请注意，除了分配给isSelectingAssetOne的值之外，上述两个实例中的代码几乎相同。您可以使用UIImagePickerController来像“播放视频”部分一样选择视频文件。所述isSelectingAssetOne变量用来识别哪个资产当前选择。 将以下代码添加到UIImagePickerController显示和处理文件的末尾： 1234567891011121314151617181920212223242526272829303132333435363738394041- （BOOL ） startMediaBrowserFromViewController ：（ UIViewController * ） controller usingDelegate ：（id ） delegate &#123; // 1 - 验证 if （（[ UIImagePickerController isSourceTypeAvailable ： UIImagePickerControllerSourceTypeSavedPhotosAlbum ] == NO ） || （ delegate == nil ） || （ controller == nil ）） &#123; return NO ; &#125; // 2 - 创建图像选择器 UIImagePickerController * mediaUI = [ [ UIImagePickerController alloc ] init ] ; mediaUI.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum; mediaUI.mediaTypes = [ [ NSArray alloc ] initWithObjects ：（NSString * ） kUTTypeMovie，nil ] ; //隐藏用于移动和缩放图片的控件，或 //修剪动画。要显示控件，请使用YES。 mediaUI.allowsEditing = YES ; mediaUI.delegate = delegate; // 3 - 显示图像选择器 [ controller presentModalViewController ： mediaUI animated ： YES ] ; 返回 YES ;&#125; - （void ） imagePickerController ：（ UIImagePickerController * ） picker didFinishPickingMediaWithInfo ：（NSDictionary * ） info &#123; // 1 - 获取媒体类型 NSString * mediaType = [ info objectForKey ： UIImagePickerControllerMediaType ] ; // 2 - 关闭图像选择器 [ self dismissModalViewControllerAnimated ：NO ] ; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Asset Loaded”消息：@ “Video One Loaded” 委托：nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; firstAsset = [ AVAsset assetWithURL ：[ info objectForKey ： UIImagePickerControllerMediaURL ] ] ; &#125; else &#123; NSLog （@ “Video two Loaded” ） ; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Asset Loaded”消息：@ “Video Two Loaded” 委托：nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; secondAsset = [ AVAsset assetWithURL ：[ info objectForKey ： UIImagePickerControllerMediaURL ] ] ; &#125; &#125; &#125; 请注意，在imagePickerController：didFinishPickingMediaWithInfo：中，您可以使用图像选择器返回的媒体URL来初始化每个资产变量。还要注意，如何使用isSelectingAssetOne变量来确定设置了哪个资产变量。 此时，您有代码可以选择两个视频资源。 编译并运行，并确保您的库中至少有两个视频。然后选择“合并视频”选项，然后选择两个视频。如果一切正常，您都可以在选择每个视频后看到“已加载资产”消息。 下一步是添加功能来选择音频文件。 UIImagePickerController仅提供从媒体库中选择视频和图像的功能。要从音乐库中选择音频文件，您将使用MPMediaPickerController。它的工作原理与UIImagePickerController完全相同，但不是图像和视频，它会访问媒体库中的音频文件。 将以下代码添加到loadAudio中： 1234MPMediaPickerController * mediaPicker = [ [ MPMediaPickerController alloc ] initWithMediaTypes ： MPMediaTypeAny ] ;mediaPicker.delegate = self;mediaPicker.prompt = @ “选择音频” ;[ self presentModalViewController ： mediaPicker animated ：YES ] ; 上述代码创建一个新的MPMediaPickerController实例，并将其显示为模态视图控制器。 建立并运行。现在，当您点击“加载音频”按钮时，您可以访问设备上的音频库。（当然，您需要在设备上安装一些音频文件，否则列表将为空。） 如果您从列表中选择一首歌曲，您会发现没有任何反应。没错，MPMediaPickerController需要委托方法！在文件末尾添加以下两种方法： 1234567891011121314151617- （无效） mediaPicker ：（ MPMediaPickerController * ） mediaPicker didPickMediaItems ：（ MPMediaItemCollection * ） mediaItemCollection &#123; 的NSArray * selectedSong = [ mediaItemCollection项] ; if （[ selectedSong count ] &gt; 0 ） &#123; MPMediaItem * songItem = [ selectedSong objectAtIndex ：0 ] ; audioAsset = [ AVAsset assetWithURL ： songURL ] ; NSLog （@ “Audio Loaded” ） ; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Asset Loaded”消息：@ “Audio Loaded” 委托：nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; &#125; [ self dismissModalViewControllerAnimated ：YES ] ;&#125; - （void ） mediaPickerDidCancel ：（ MPMediaPickerController * ） mediaPicker &#123; [ self dismissModalViewControllerAnimated ： YES ] ;&#125; 代码非常类似于UIImagePickerController的委托方法。您可以根据通过MPMediaPickerController选择的媒体项来设置音频资源。 建立并再次运行。转到合并视频屏幕并选择音频文件。如果没有错误，您应该看到“加载音频”消息。 您现在可以正确加载所有视频和音频资源。现在是时候将各种媒体文件合并成一个文件了。 但是在你进入该代码之前，你必须做一点设置。将以下代码添加到mergeAndSave：： 123456789101112131415161718192021222324252627282930313233343536if （ firstAsset ！= nil &amp;&amp; secondAsset ！= nil ） &#123; [ activityView startAnimating ] ; // 1 - 创建AVMutableComposition对象。此对象将保存您的AVMutableCompositionTrack实例。 AVMutableComposition * mixComposition = [ [ AVMutableComposition alloc ] init ] ; // 2 - 视频轨道 AVMutableCompositionTrack * firstTrack = [ mixComposition addMutableTrackWithMediaType ： AVMediaTypeVideo preferredTrackID ： kCMPersistentTrackID_Invalid ] ; [ firstTrack insertTimeRange ： CMTimeRangeMake （ kCMTimeZero，firstAsset.duration ） ofTrack ：[ [ firstAsset tracksWithMediaType ： AVMediaTypeVideo ] objectAtIndex ：0 ] atTime ： kCMTimeZero误差：零] ; [ firstTrack insertTimeRange ： CMTimeRangeMake （ kCMTimeZero，secondAsset.duration ） ofTrack ：[ [ secondAsset tracksWithMediaType ： AVMediaTypeVideo ] objectAtIndex ：0 ] atTime ： firstAsset.duration error ：nil ] ; // 3 - 音频轨道 if （ audioAsset ！= nil ）&#123; AVMutableCompositionTrack * AudioTrack = [ mixComposition addMutableTrackWithMediaType ： AVMediaTypeAudio 0 ] atTime ： firstAsset.duration error ：nil ] ; // 3 - 音频轨道if （ audioAsset ！= nil ）&#123; AVMutableCompositionTrack * AudioTrack = [ mixComposition addMutableTrackWithMediaType ： AVMediaTypeAudio 0 ] atTime ： firstAsset.duration error ：nil ] ; // 3 - 音频轨道if （ audioAsset ！= nil ）&#123; AVMutableCompositionTrack * AudioTrack = [ mixComposition addMutableTrackWithMediaType ： AVMediaTypeAudio preferredTrackID ： kCMPersistentTrackID_Invalid ] ; [ AudioTrack insertTimeRange ： CMTimeRangeMake （ kCMTimeZero，CMTimeAdd （ firstAsset.duration，secondAsset.duration ）） ofTrack ：[ [ audioAsset tracksWithMediaType ： AVMediaTypeAudio ] objectAtIndex ：0 ] atTime ： kCMTimeZero误差：零] ; &#125; // 4 - 获取路径 NSArray * paths = NSSearchPathForDirectoriesInDomains （ NSDocumentDirectory，NSUserDomainMask，YES ） ; NSString * documentsDirectory = [ paths objectAtIndex ：0 ] ; NSString * myPathDocs = [ documentsDirectory stringByAppendingPathComponent ： [ NSString stringWithFormat ：@ “mergeVideo-％d.mov”，arc4random （） ％ 1000 ] ] ; NSURL * url = [ NSURL fileURLWithPath ： myPathDocs ] ; // 5 - 创建导出器 AVAssetExportSession * exporter = [ [ AVAssetExportSession alloc ] initWithAsset ： mixComposition presetName ： AVAssetExportPresetHighestQuality ] ; exporter.outputURL = url; exporter.outputFileType = AVFileTypeQuickTimeMovie; exporter.shouldOptimizeForNetworkUse = YES ; [ exporter exportAsynchronouslyWithCompletionHandler ：^ &#123; dispatch_async （ dispatch_get_main_queue （），^ &#123; [ self exportDidFinish ： exporter ] ; &#125; ） ; &#125; ] ; &#125; 以下是上述代码的分步细分： 您创建一个AVMutableComposition对象来保存视频和音轨以及变换效果。 接下来，您将为视频创建AVMutableCompositionTrack，并将其添加到AVMutableComposition对象。然后将两个视频插入到新创建的AVMutableCompositionTrack中。 请注意，insertTimeRange方法允许您将视频的一部分插入主要合成而不是整个视频。这样，您可以将视频剪辑到您所选择的时间范围。 在这种情况下，您要插入整个视频，因此您可以创建一个从kCMTimeZero到您的视频资源持续时间的时间范围。atTime参数允许您将您的视频/音轨放在您想要的组合中。注意如何firstAsset被插入在时间零点，和secondAsset被插入在所述第一视频的结尾。本教程假设您希望您的视频资产一个接一个。但是您也可以通过玩时间范围来重叠资产。 对于使用时间范围，您可以使用CMTime结构体。CMTime结构是表示时间的非透明可变结构体，其中时间可以是时间戳或持续时间。 同样，您为音频创建一个新曲目[AVMutableCompositionTrack？]，并将其添加到主要作品中。这次您将音频时间范围设置为第一和第二个视频的持续时间的总和，因为这将是视频的完整长度。 在保存最终视频之前，您需要保存文件的路径。因此，创建一个随机文件名，指向文档文件夹中的文件。 最后，渲染和导出合并的视频。为此，您将创建一个AVAssetExportSession对象，该对象对AVAsset源对象的内容进行转码，以创建由指定的导出预设描述的窗体的输出。 在使用包含源介质的资产，导出预设名称（presetName）和输出文件类型（outputFileType）初始化导出会话后，通过调用exportAsynchronouslyWithCompletionHandler：启动导出。 因为导出是异步执行的，所以该方法立即返回。exportAsynchronouslyWithCompletionHandler提供的完成处理程序：是否导出失败，完成或被取消。完成后，出口商的状态属性表示出口是否成功完成。如果失败，导出器的错误属性的值提供有关失败原因的其他信息。 请注意，完成处理程序调用exportDidFinish：一个需要实现的方法。将以下代码添加到文件末尾： 12345678910111213141516171819202122232425- （void ） exportDidFinish ：（ AVAssetExportSession * ） session &#123; if （ session.status == AVAssetExportSessionStatusCompleted ） &#123; NSURL * outputURL = session.outputURL; ALAssetsLibrary * library = [ [ ALAssetsLibrary alloc ] init ] ; 如果 （[库videoAtPathIsCompatibleWithSavedPhotosAlbum ： outputURL ] ） &#123; [库writeVideoAtPathToSavedPhotosAlbum ： outputURL completionBlock ：^ （NSURL * assetURL，NSError *错误）&#123; dispatch_async （ dispatch_get_main_queue （），^ &#123; if （ error ） &#123; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Error” message ：@ “Video Saving Failed” 委托：nil cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; &#125; else &#123; UIAlertView * alert = [ [ UIAlertView alloc ] initWithTitle ：@ “Video Saved”消息：@ “保存到相册” 委托： self cancelButtonTitle ：@ “OK” otherButtonTitles ：nil ] ; [警报显示] ; &#125; &#125; ） ; &#125; ] ; &#125; &#125; audioAsset = nil ; firstAsset = nil ; secondAsset = nil ; [ activityView stopAnimating ] ;&#125; 导出成功完成后，新导出的视频将保存到相册中。您实际上不需要做 - 您可以使用AssetBrowser浏览到您保存到文档文件夹的最终视频。但是，将输出视频复制到相册更容易，以便您可以看到最终的输出。 继续，建立并运行您的项目！ 选择视频和音频文件并合并选定的文件。如果合并成功，您应该看到一个“视频保存”消息。此时，您的新视频应该存在于相册中。 转到相册，或使用自己的“选择和播放视频”屏幕浏览！您会注意到，虽然视频已经合并，但有一些方向问题。肖像视频处于横向模式，有时视频会颠倒。 这是由于默认的AVAsset方向。使用默认iPhone摄像头应用程序录制的所有影片和影像文件都将视频帧设置为横向，因此媒体将以横向模式保存。 AVAsset有一个preferredTransform属性，其中包含媒体方向信息，每当您使用照片应用程序或QuickTime查看媒体文件时，它将应用于媒体文件。在上面的代码中，您尚未对AVAsset对象应用转换，因此导向问题。 您可以通过将必要的转换应用到您的AVAsset对象来轻松更正。但是，由于您的两个视频文件具有不同的方向，因此您需要使用两个独立的AVMutableCompositionTrack实例，而不是像您最初一样。 将mergeAndSave中的第2个部分替换为以下，以便您有两个AVMutableCompositionTrack实例而不是一个： 123456789// 2 - 创建两个视频轨道 AVMutableCompositionTrack * firstTrack = [ mixComposition addMutableTrackWithMediaType ： AVMediaTypeVideo preferredTrackID ： kCMPersistentTrackID_Invalid ] ;[ firstTrack insertTimeRange ： CMTimeRangeMake （ kCMTimeZero，firstAsset.duration ） ofTrack ：[ [ firstAsset tracksWithMediaType ： AVMediaTypeVideo ] objectAtIndex ：0 ] atTime ： kCMTimeZero误差：零] ;AVMutableCompositionTrack * secondTrack = [ mixComposition addMutableTrackWithMediaType ： AVMediaTypeVideo preferredTrackID ： kCMPersistentTrackID_Invalid ] ;[ secondTrack insertTimeRange ： CMTimeRangeMake （ kCMTimeZero，secondAsset.duration ） ofTrack ：[ [ secondAsset tracksWithMediaType ： AVMediaTypeVideo ] objectAtIndex ：0 ] atTime ： firstAsset.duration误差：零] ; 由于您现在有两个独立的AVMutableCompositionTrack实例，因此您需要将AVMutableVideoCompositionLayerInstruction应用于每个轨道，以便修复方向。所以在你刚刚替换的代码之后添加以下代码（在第3节之前）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 2.1 - 创建AVMutableVideoCompositionInstruction AVMutableVideoCompositionInstruction * mainInstruction = [ AVMutableVideoCompositionInstruction videoCompositionInstruction ] ;mainInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, CMTimeAdd(firstAsset.duration, secondAsset.duration));// 2.2 - Create an AVMutableVideoCompositionLayerInstruction for the first trackAVMutableVideoCompositionLayerInstruction *firstlayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:firstTrack];AVAssetTrack *firstAssetTrack = [[firstAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];UIImageOrientation firstAssetOrientation_ = UIImageOrientationUp;BOOL isFirstAssetPortrait_ = NO;CGAffineTransform firstTransform = firstAssetTrack.preferredTransform;if (firstTransform.a == 0 &amp;&amp; firstTransform.b == 1.0 &amp;&amp; firstTransform.c == -1.0 &amp;&amp; firstTransform.d == 0) &#123; firstAssetOrientation_ = UIImageOrientationRight; isFirstAssetPortrait_ = YES;&#125;if (firstTransform.a == 0 &amp;&amp; firstTransform.b == -1.0 &amp;&amp; firstTransform.c == 1.0 &amp;&amp; firstTransform.d == 0) &#123; firstAssetOrientation_ = UIImageOrientationLeft; isFirstAssetPortrait_ = YES;&#125;if (firstTransform.a == 1.0 &amp;&amp; firstTransform.b == 0 &amp;&amp; firstTransform.c == 0 &amp;&amp; firstTransform.d == 1.0) &#123; firstAssetOrientation_ = UIImageOrientationUp;&#125;if (firstTransform.a == -1.0 &amp;&amp; firstTransform.b == 0 &amp;&amp; firstTransform.c == 0 &amp;&amp; firstTransform.d == -1.0) &#123; firstAssetOrientation_ = UIImageOrientationDown;&#125;[firstlayerInstruction setTransform:firstAsset.preferredTransform atTime:kCMTimeZero];[firstlayerInstruction setOpacity:0.0 atTime:firstAsset.duration];// 2.3 - Create an AVMutableVideoCompositionLayerInstruction for the second trackAVMutableVideoCompositionLayerInstruction *secondlayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:secondTrack];AVAssetTrack *secondAssetTrack = [[secondAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];UIImageOrientation secondAssetOrientation_ = UIImageOrientationUp;BOOL isSecondAssetPortrait_ = NO;CGAffineTransform secondTransform = secondAssetTrack.preferredTransform;if (secondTransform.a == 0 &amp;&amp; secondTransform.b == 1.0 &amp;&amp; secondTransform.c == -1.0 &amp;&amp; secondTransform.d == 0) &#123; secondAssetOrientation_= UIImageOrientationRight; isSecondAssetPortrait_ = YES;&#125;if (secondTransform.a == 0 &amp;&amp; secondTransform.b == -1.0 &amp;&amp; secondTransform.c == 1.0 &amp;&amp; secondTransform.d == 0) &#123; secondAssetOrientation_ = UIImageOrientationLeft; isSecondAssetPortrait_ = YES;&#125;if (secondTransform.a == 1.0 &amp;&amp; secondTransform.b == 0 &amp;&amp; secondTransform.c == 0 &amp;&amp; secondTransform.d == 1.0) &#123; secondAssetOrientation_ = UIImageOrientationUp;&#125;if (secondTransform.a == -1.0 &amp;&amp; secondTransform.b == 0 &amp;&amp; secondTransform.c == 0 &amp;&amp; secondTransform.d == -1.0) &#123; secondAssetOrientation_ = UIImageOrientationDown;&#125;[secondlayerInstruction setTransform:secondAsset.preferredTransform atTime:firstAsset.duration];&#125; 在第2.1节中，您将创建一个AVMutableVideoCompositionInstruction对象，该对象将保存图层指令。 然后在第2.2节中，将方向固定添加到第一个轨道，如下所示： 您创建一个AVMutableVideoCompositionLayerInstruction并将其与您的firstTrack相关联。 接下来，您将从AVAsset创建一个AVAssetTrack对象。AVAssetTrack对象为所有资产提供轨道级检查界面。您需要此对象才能访问资产的preferredTransform和dimension。 然后，确定您的AVAsset的方向。这将在确定导出的视频大小时稍后使用。 接下来，应用preferredTransform来修复方向。 您还将firstAsset.duration的第一层的不透明度设置为零。这是因为您希望您的第一首曲目在完成播放后消失。否则，第一轨道的最后一帧将保持在屏幕上，并与来自第二轨道的视频重叠。 2.3节中的代码与＃2.2节中的代码几乎相同。这只是应用于第二轨道的方向固定。 接下来，在第2.3节之后添加以下代码（在第3节之前）： 123456789101112131415161718192021222324252627282930// 2.4 - 添加指令 mainInstruction.layerInstructions = [ NSArray arrayWithObjects ： firstlayerInstruction，secondlayerInstruction，nil ] ;AVMutableVideoComposition * mainCompositionInst = [ AVMutableVideoComposition videoComposition ] ;mainCompositionInst.instructions = [ NSArray arrayWithObject ： mainInstruction ] ;mainCompositionInst.frameDuration = CMTimeMake （1，30 ） ; CGSize naturalSizeFirst，naturalSizeSecond;if （ isFirstAssetPortrait_ ）&#123; naturalSizeFirst = CGSizeMake （ FirstAssetTrack.naturalSize.height，FirstAssetTrack.naturalSize.width ） ;&#125; else &#123; naturalSizeFirst = FirstAssetTrack.naturalSize;&#125; if （ isSecondAssetPortrait_ ）&#123; naturalSizeSecond = CGSizeMake （ SecondAssetTrack.naturalSize.height，SecondAssetTrack.naturalSize.width ） ;&#125; else &#123; naturalSizeSecond = SecondAssetTrack.naturalSize;&#125; float renderWidth，renderHeight;if （ naturalSizeFirst.width&gt; naturalSizeSecond.width ） &#123; renderWidth = naturalSizeFirst.width;&#125; else &#123; renderWidth = naturalSizeSecond.width;&#125; if （ naturalSizeFirst.height&gt; naturalSizeSecond.height ） &#123; renderHeight = naturalSizeFirst.height;&#125; else &#123; renderHeight = naturalSizeSecond.height;&#125; MainCompositionInst.renderSize = CGSizeMake （ renderWidth， 现在您有第一和第二个曲目的AVMutableVideoCompositionLayerInstruction实例，您只需将它们添加到主AVMutableVideoCompositionInstruction对象即可。接下来，将mainInstruction对象添加到AVMutableVideoComposition实例的instructions属性中。您还将组合的帧速率设置为30帧/秒。 那么你必须找到最终视频的导出大小。首先我们要检查资源是纵向还是横向。为此，我们从前面使用变量isFirstAssetPortrait和isSecondAssetPortrait。如果它们是风景，我们可以使用我们提供的naturalSize属性，但是如果它们是纵向的，我们必须翻转naturalSize，使得宽度现在是高度，反之亦然。我们将每个结果保存到变量中。 那么我们必须确定两个资产中哪一个是更广泛的，哪一个是较高的。这是为了确保导出的视频足够大以容纳所有的每个视频。通过一些简单的比较，我们将结果保存到变量中。 然后，您可以将导出的renderSize设置为找到的renderWidth和renderHeight。 现在，您已经配置了一个AVMutableVideoComposition对象，所有您需要做的是将其分配给您的导出器。在第5节中，在该部分的第4行之后插入以下代码（就在exportAsynchronouslyWithCompletionHandler： call 之前）： 1exporter.videoComposition = mainCompositionInst; 呃 - 就是这样！ 构建并运行您的项目。如果您通过组合两个视频（可选的音频文件）创建一个新的视频，您将看到当您播放新的合并的视频时，方向问题已经消失。","tags":[]},{"title":"个人简历","date":"2017-04-13T09:01:36.000Z","path":"/uncategorized/个人简历.html","text":"个人信息姓名：祁伟鹏&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生日：1992.09.20 学历：本科&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;专业： 计算机科学与技术 期望薪资：15000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工作经验：3年 学习经历 时间段 类型 学校 专业 2013.12~2014.06 培训 千峰教育 iOS应用开发 2010.09~2014.06 统招 集宁师范学院 计算机科学与技术 工作经历北京育学林教育技术有限公司工作时间：2016.5~ 职位：iOS开发工程师&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;薪资：18000 工作内容： 独立完成公司iOS产品开发维护 iOS产品需求分析 协同技术部负责人管理前端开发人员 北京沃安科技有限公司工作时间：2014.6~2016.3 职位：iOS开发工程师&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;薪资：13000 工作内容： 独立完成公司iOS产品的开发维护 iOS产品需求分析 项目简介京版云（已上线）应用链接 项目背景： 基于北京出版集团提供的资源，打造一个面向于教师家长学生的平台。包括资源的上传下载，分享查看，班级信息的管理。 开发部分： 所有功能。 功能点： 定位学生、班级信息管理、电子课本、语音跟读、多媒体消息发布、个人资源库管理、参加活动 直播客（已上线）应用链接 项目背景： 早期视频直播应用，14年一开发完毕，不断更新。公司自主开发视频服务器，对上传视频进行软硬解码，生成m3u8视频流。用户可以直播并将观看链接分享至微信，其他人就可通过分享出的链接看直播。直播因使用m3u8流有延迟0s~8s。 开发部分： 所有功能。 功能： 微信登录、视频直播、微信分享、视频管理 懂你心理（待上线）项目背景： 正在内测中，针对需要心理帮助的群体。 开发部分： 所有功能。 功能： 资讯、心理测评、用户群组 医带医路（已上线）应用链接 项目背景： 与北京301医院合作的医生转诊平台，因融资失败已不维护。 开发部分： 所有功能。 功能： 医生间咨询功能、医生视频直播功能、直播互动功能、打赏功能、病历档案、群聊 刷脸（已上线）项目背景： 该应用已下架，熟人借贷APP。 开发部分： 所有功能。 功能： 利率计算、通讯录获取、消息通知、弹幕、还款计划、借款计划、第三方支付 戴雅（已上线）应用链接 项目背景： 融资失败，项目后台已不能使用。是一款商城类APP主要针对文玩珠子。 开发部分： 除3D模块。 功能： 社区功能、银联支付、咨询功能、商品交易功能、3D展示功能、自定义3D模型功能","tags":[]},{"title":"SpringBoot开发Web应用","date":"2017-03-27T07:16:23.000Z","path":"/uncategorized/SpringBoot开发Web应用.html","text":"","tags":[]},{"title":"SpringBoot快速入门","date":"2017-03-27T07:15:53.000Z","path":"/uncategorized/SpringBoot快速入门.html","text":"","tags":[]},{"title":"Java常见对象之集合","date":"2017-03-27T07:14:44.000Z","path":"/uncategorized/Java常见对象之集合.html","text":"","tags":[]},{"title":"Java常见对象之字符串","date":"2017-03-27T07:14:03.000Z","path":"/uncategorized/Java常见对象之字符串.html","text":"","tags":[]},{"title":"Java面向对象","date":"2017-03-27T07:13:25.000Z","path":"/uncategorized/Java面向对象.html","text":"","tags":[]},{"title":"Java编程基础","date":"2017-03-27T07:12:19.000Z","path":"/uncategorized/Java编程基础.html","text":"本文来源于黑马J2EE培训教学笔记。博主又进行整理，掺杂自己的一些学习笔记，供大家学习。学习编程之前，我们首先要了解计算机的一些基本知识。本文讲解的一些基础知识，适合没有学习过计算机语言的小伙伴们了解。 本文知识点 计算机基础知识 常量与变量的使用 常见运算符的基本用法 流程控制语句 计算机基础知识计算机概述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是计算机? 计算机（Computer）全称：电子计算机，俗称电脑。是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成，没有安装任何软件的计算机称为裸机。常见的形式有台式计算机、笔记本计算机、大型计算机等。 计算机的应用举例 1：科学计算 2、数据处理 3、自动控制 4、计算机辅助设计 5、人工智能 6、多媒体应用 7、计算机网络 … &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是硬件?计算机硬件（Computer Hardware）是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础。 计算机的硬件分成5大组成部件：运算器、控制器、存储器、输入设备和输出设备。 运算器和控制器是计算机的核心，合称中央处理单元（Central Processing Unit，CPU）或处理器。CPU的内部还有一些高速存储单元，被称为寄存器。其中运算器执行所有的算术和逻辑运算；控制器负责把指令逐条从存储器中取出，经译码后向计算机发出各种控制命令；而寄存器为处理单元提供操作所需要的数据。 存储器是计算机的记忆部分，用来存放程序以及程序中涉及的数据。它分为内部存储器和外部存储器。内部存储器用于存放正在执行的程序和使用的数据，其成本高、容量小，但速度快。外部存储器可用于长期保存大量程序和数据，其成本低、容量大，但速度较慢。 输入设备和输出设备统称为外部设备，简称外设或I/O设备，用来实现人机交互和机间通信。微型机中常用的输入设备有键盘、鼠标等，输出设备有显示器、打印机等。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是软件?计算机软件(Computer Software)是使用计算机过程中必不可少的东西，计算机软件可以使计算机按照事先预定好的顺序完成特定的功能。计算机软件按照其功能划分为系统软件与应用软件： 系统软件： DOS(Disk Operating System), Windows, Linux, Unix, Mac, Android, iOS 应用软件：office QQ聊天 YY语言 扫雷 软件开发和计算机语言概述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是软件？软件就是按照特定顺序组织的计算机数据和指令的集合。什么是开发?简单来说开发就是软件的制作过程。什么是软件开发？借助开发工具与计算机语言制作软件。什么是计算机语言？人与计算机之间进行信息交流沟通的一种特殊语言。 计算机语言的分类 机器语言：机器语言是直接用二进制代码指令表达的计算机语言，指令是用0和1组成的一串代码，它们有一定的位数，并分成若干段，各段的编码表示不同的含义。 汇编语言：汇编语言是使用一些特殊的符号来代替机器语言的二进制码，计算机不能直接识别，需要用一种软件将汇编语言翻译成机器语言。 高级语言： 使用普通英语进行编写源代码，通过编译器将源代码翻译成计算机直接识别的机器语言，之后再由计算机执行。 高级语言包括C,C++,C#,JAVA 人机交互 A:人机交互的两种方式 a:命令行方式 需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令。 b:图形化界面方式 这种方式简单直观，使用者易于接受，容易上手操作。 常见的DOS命令在这里我们说一下windows系统中中常用的DOS命令有哪些，使用DOS命令需要先打开DOS控制台。 如何打开DOS控制台 xp下如何打开DOS控制台？ a:开始–程序–附件–命令提示符 b:开始–运行–cmd–回车 c:win+r–cmd–回车 win7下如何打开DOS控制台？ a:开始–所有程序–附件–命令提示符 b:开始–搜索程序和文件–cmd–回车 c:win+r–cmd–回车 win8下如何打开DOS控制台 a:鼠标左击开始–下箭头–命令提示符 b:鼠标右击开始–搜索–cmd–回车 c:鼠标右击开始–运行–cmd–回车 d:win+r–cmd–回车 DOS命令 d: 回车 盘符切换 dir(directory):列出当前目录下的文件以及文件夹 cd (change directory)改变指定目录(进入指定目录) cd.. : 退回到上一级目录 cd\\: 退回到根目录 cls : (clear screen)清屏 exit : 退出dos命令行 md (make directory) : 创建目录 rd (remove directory): 删除目录 del (delete): 删除文件,删除一堆后缀名一样的文件*.txt notepad 创建文件 删除带内容的文件夹 rd + /s 文件夹名称(询问是否删除) rd + /q + /s 文件夹名称(直接删除) Java语言基础Java语言概述Java语言发展史 詹姆斯·高斯林（James Gosling）1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司，1990年，与Patrick，Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak”，后改名为Java。 注：SUN(Stanford University Network，斯坦福大学网络公司) Java语言版本JDK 1.1.4 Sparkler 宝石 1997-09-12 JDK 1.1.5 Pumpkin 南瓜 1997-12-13 JDK 1.1.6 Abigail 阿比盖尔--女子名 1998-04-24 JDK 1.1.7 Brutus 布鲁图--古罗马政治家和将军 1998-09-28 JDK 1.1.8 Chelsea 切尔西--城市名 1999-04-08 J2SE 1.2 Playground 运动场 1998-12-04 J2SE 1.2.1 none 无 1999-03-30 J2SE 1.2.2 Cricket 蟋蟀 1999-07-08 J2SE 1.3 Kestrel 美洲红隼(sǔn) 2000-05-08 J2SE 1.3.1 Ladybird 瓢虫 2001-05-17 J2SE 1.4.0 Merlin 灰背隼 2002-02-13 J2SE 1.4.1 grasshopper 蚱蜢 2002-09-16 J2SE 1.4.2 Mantis 螳螂 2003-06-26 JAVASE 5.0 (1.5.0) Tiger 老虎 JAVASE 5.1 (1.5.1) Dragonfly 蜻蜓 JAVASE 6.0 (1.6.0) Mustang 野马 JAVASE 7.0 (1.7.0) Dolphin 海豚 Java语言平台J2SE(Java 2 Platform Standard Edition)标准版 是为开发普通桌面和商务应用程序提供的解决方案,该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发 J2ME(Java 2 Platform Micro Edition)小型版 是为开发电子消费产品和嵌入式设备提供的解决方案 J2EE(Java 2 Platform Enterprise Edition)企业版 是为开发企业环境下的应用程序提供的一套解决方案,该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发 Java语言特性 简单性 解释性 面向对象 高性能 分布式处理 多线程 健壮性 动态 结构中立 安全性 开源 跨平台 Java语言跨平台原理Java语言开发的应用可以在不同平台上运行。只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。 write once ,run anywhere!(一处编译,到处运行) JRE和JDK的概述 什么是JRE 包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 JRE:JVM+类库。 什么是JDK JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。 其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等 JDK:JRE+JAVA的开发工具。 为什么JDK中包含一个JRE 为什么JDK中包含一个JRE呢？ 开发完的程序，需要运行一下看看效果。 JDK的下载和安装过程图解 A:JDK的下载 a:官网 http://www.oracle.com b:演示下载流程 B:JDK的安装 a:傻瓜式安装 双击安装程序，然后一路next即可(但是不建议) b:安装的推荐方式 安装路径不要有中文或者特殊符号如空格等。 所有和开发相关的软件最好安装目录统一。 举例：我的JDK安装路径 D:\\develop\\Java\\jdk1.7.0_72 当提示安装JRE时，可以选择不安装。建议还是安装上。 c:演示安装流程 可以先在d盘建立一个文件夹develop 然后演示安装过程 C:验证安装是否成功 a:通过DOS命令，切换到JDK安装的bin目录下。 D:\\develop\\Java\\jdk1.7.0_72\\bin b:然后分别输入javac和java，如果正常显示一些内容，说明安装成功 JDK安装路径下的目录解释 a:bin目录：该目录用于存放一些可执行程序。 如javac.exe（java编译器）、java.exe(java运行工具)，jar.exe(打包工具)和* javadoc.exe(文档生成工具)等。 b:db目录：db目录是一个小型的数据库。 从JDK 6.0开始，Java中引用了一个新的成员JavaDB，这是一个纯Java实现、开源的数据库管理系统。这个数据库不仅轻便，而且支持JDBC 4.0所有的规范，在学习JDBC 时，不再需要额外地安装一个数据库软件，选择直接使用JavaDB即可。 c:jre目录：”jre”是 Java Runtime Environment 的缩写，意为Java程序运行时环境。此目录是Java运行时环境的根目录，它包括Java虚拟机，运行时的类包，Java应用启动器以及一个bin目录，但不包含开发环境中的开发工具。 d:include目录：由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是用于存放这些头文件的。 e:lib目录：lib是library的缩写，意为 Java 类库或库文件，是开发工具使用的归档包文件。 f:src.zip文件：src.zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码，通过该文件可以查看Java基础类的源代码。 Path环境变量的作用及配置方式1 A:在JDK的bin目录下开发程序容易产生的问题 a:如果文件过多，不方便管理 b:删除自己写过的不需要的文件，可能不小心把JDK自带的工具给删除了 B:如何解决问题呢 notepad这样的命令为什么在任何路径下都能够执行,配置path环境变量 C:配置方式 a:xp系统 右键点击桌面计算机→选择属性→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。 b:win7/win8系统 右键点击桌面计算机→选择属性→选择高级系统设置→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。 path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件 Path环境变量的配置方式2 A:先配置JAVA_HOME B:再修改path C:最后说一下path是有先后顺序关系的 classpath环境变量的作用及其配置 A:为什么要配置classpath B:classpath配置的原理 C:如何配置classpath path和classpath的区别 path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件 classpath配置的java的类文件,就是.class文件 Java开发工具介绍 A:notepad(微软操作系统自带) B:Editplus/Notepad++ C:Eclipse D:MyEclipse 给大家简单的介绍一下这些工具，然后说说我们使用这些工具的顺序。 基础班：先notepad，然后Editplus，再Eclipse。 就业班：MyEclipse和Eclipse都用。 Editplus开发程序并编译运行 A:配置快捷键编译运行 B:去除备份文件 第一个Java程序HelloWorld案例的编写和运行 A:定义类 B:写main方法 C:写输出语句 D:Java程序开发运行与工作原理 E:编译和运行程序 12345class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"HelloWorld\"); &#125;&#125; HelloWorld案例常见问题 A:找不到文件(都演示一下，让学生看看出现的都是什么问题) a:文件扩展名隐藏导致编译失败 b:文件名写错了 B:单词拼写问题(都演示一下，让学生看看出现的都是什么问题) a:class写成Class b:String写成string c:System写成system d:main写成mian C:括号匹配问题(都演示一下，让学生看看出现的都是什么问题) a:把类体的那对大括号弄掉一个 b:把方法体的那对大括号弄掉一个 c:把输出语句的那对小括号弄掉一个 D:中英文问题(都演示一下，让学生看看出现的都是什么问题) a:提示信息：错误: 非法字符: \\????的格式 注意：java编程中需要的基本上都是英文字符 Java语言的书写格式(约定俗成) 1,大括号要对齐,并且成对写 2,左大括号前面有空格 3,遇到左大括号要缩进,Tab 4,方法和程序块之间加空行让程序看起来清晰 5,并排语句之间加空格,例如for语句 6,运算符两侧加空格 注释概述及其分类 A:什么是注释 B:注释的分类及讲解 文档注释目前不讲，说后面讲解 注释的作用 A:解释说明程序 B:帮助我们调试错误 关键字的概述和使用 A:什么是关键字 被Java语言赋予特定含义的单词 B:关键字的特点 组成关键字的字母全部小写 C:常见关键字 public static void class等 D:关键字的注意事项 goto和const作为保留字存在,目前并不使用,类似Editplus这样的高级记事本,针对关键字有特殊的颜色标记，非常直观 标识符的概述和组成规则 A:什么是标识符 就是给类,接口,方法,变量等起名字时使用的字符序列 B:标识符的组成规则 英文大小写字母 数字字符 $和_ C:标识符注意事项 1,不能使用关键字 2,不能数字开头 标识符中常见的命名规则 见名知意 A:包 最好是域名倒过来,要求所有的字母小写 B:类或者接口 如果是一个单词首字母大写 如果是多个单词每个单词首字母大写(驼峰标识) C:方法或者变量 如果是一个单词全部小写 如果是多个单词,从第二个单词首字母大写 D:常量 如果是一个单词,所有字母大写 如果是多个单词,所有的单词大写,用下划线区分每个单词 常量与进制转换常量的概述和使用 A:什么是常量 在程序执行的过程中其值不可以发生改变 B:Java中常量的分类 字面值常量 自定义常量(面向对象部分讲) C:字面值常量的分类 字符串常量 用双引号括起来的内容 整数常量 所有整数 小数常量 所有小数 字符常量 用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号 布尔常量 较为特殊，只有true和false 空常量 null(数组部分讲解) D:案例演示 用输出语句输出各种常量。null不演示 进制概述和二,八,十六进制图解 A:什么是进制 进制：就是进位制，是人们规定的一种进位方法。 对于任何一种进制–X进制，就表示某一位置上的数运算时是逢X进一位。二进制就是逢二进一，八进制是逢八进一，十进制是逢十进一，十六进制是逢十六进一。 例如一周有七天,七进制,一年有十二个月,十二进制 B:十进制的由来 十进制的由来是因为人类有十个手指 C:二进制的由来 其实二进制来源与中国,请看史料记载 18世纪德国数理哲学大师莱布尼兹从他的传教士朋友鲍威特寄给他的拉丁文译本《易经》中，读到了八卦的组成结构，惊奇地发现其基本素数（0）（1），即《易经》的阴爻yao- -和__阳爻，其进位制就是二进制，并认为这是世界上数学进制中最先进的。20世纪被称作第三次科技革命的重要标志之一的计算机的发明与应用，其运算模式正是二进制。它不但证明了莱布尼兹的原理是正确的，同时也证明了《易经》数理学是很了不起的。 D:八进制的由来 任何数据在计算机中都是以二进制的形式存在的。二进制早期由电信号开关演变而来。一个整数在内存中一样也是二进制的，但是使用一大串的1或者0组成的数值进行使用很麻烦。 所以就想把一大串缩短点，将二进制中的三位用一位表示。这三位可以取到的最大值就是7.超过7就进位了，这就是八进制。 E:十六进制的由来 但是对于过长的二进制变成八进制还是较长，所以出现的用4个二进制位表示一位的情况，四个二进制位最大是15，这就是十六进制。 F:不同进制表现同一个数据的形式特点 进制越大，表现形式越短 不同进制数据的表现形式 A:二进制的数据表现形式 由0,1组成。以0b(b可以大写也可以小写)开头(JDK1.7版本可以表示二进制了) B:八进制的数据表现形式 由0,1,…7组成。以0开头 C:十进制的数据表现形式 由0,1,…9组成。整数默认是十进制的 D:十六进制的数据表现形式 由0,1,…9,a,b,c,d,e,f(大小写均可)。以0x开头 E:案例演示 输出不同进制表现100的数据。 0b100 0100 100 0x100 任意进制到十进制的转换图解 A:任意进制到十进制的转换原理 系数：就是每一位上的数据。 基数：X进制，基数就是X。 权：在右边，从0开始编号，对应位上的编号即为该位的权。 结果：把系数*基数的权次幂相加即可。 B:画图练习 二进制–十进制 八进制–十进制 十六进制–十进制 十进制到任意进制的转换图解 A:十进制到任意进制的转换原理 除积倒取余 B:画图练习 十进制–二进制 十进制–八进制 十进制–十六进制 快速的进制转换法 A:8421码及特点 8421码是中国大陆的叫法，8421码是BCD代码中最常用的一种。在这种编码方式中每一位二值代码的1都是代表一个固定数值，把每一位的1代表的十进制数加起来，得到的结果就是它所代表的十进制数码。 B:通过8421码的方式进行二进制和十进制的相互转换 C:二进制到八进制的简易方式 D:二进制到十六进制的简易方式 原码反码补码 A:为什么要学习原码反码补码? 后面要学习强制类型转换,如果不知道有原反补会看不懂结果 B:有符号数据表示法的几种方式 原码 就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。 通过一个字节,也就是8个二进制位表示+7和-7 0(符号位) 0000111 1(符号位) 0000111 反码 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码 正数的补码与其原码相同；负数的补码是在其反码的末位加1。 A:已知原码求补码 0b10110100 B:已知补码求原码 0b11101110 变量与数据类型转换变量的概述及格式 A:什么是变量 在程序执行的过程中，在某个范围内其值可以发生改变的量 B:变量的定义格式 数据类型 变量名 = 变量值; C:为什么要定义变量 用来不断的存放同一类型的常量，并可以重复使用 数据类型的概述和分类 A:为什么有数据类型 Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间 B:Java中数据类型的分类 基本数据类型 引用数据类型 面向对象部分讲解 C:基本数据类型分类(4类8种) 整数型 byte 占一个字节 -128到127 short 占两个字 -2^15~2^15-1 int 占四个字节 -2^31~2^31-1 long 占八个字节 -2^63~2^63-1 浮点型 float 占四个字节 -3.403E38~3.403E38 单精度 double 占八个字节-1.798E308~1.798E308 双精度 字符型 char 占两个字节 0~65535 布尔型 boolean boolean理论上是占八分之一个字节,因为一个开关就可以决定是true和false了,但是java中boolean类型没有明确指定他的大小 定义不同数据类型的变量 A:案例演示 定义不同基本数据类型的变量，并输出 赋值时候注意float类型,long类型 使用变量的注意事项 A:案例演示 a:作用域问题 同一个区域不能使用相同的变量名 b:初始化值问题 局部变量在使用之前必须赋值 c:一条语句可以定义几个变量 int a,b,c…; 数据类型转换之隐式转换 A:案例演示 a:int + int b:byte + int B:Java中的默认转换规则 取值范围小的数据类型与取值范围大的数据类型进行运算,会先将小的数据类型提升为大的,再运算 C:画图解释byte+int类型的问题 数据类型转换之强制转换 A:强制转换问题 int a = 10; byte b = 20; b = a + b; B:强制转换的格式 b = (byte)(a + b); C:强制转换的注意事项 如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同 面试题之变量相加和常量相加的区别 A:案例演示 面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。 byte b1 = 3; byte b2 = 4; byte b3 = b1 + b2; 从两方面去回答这个题 b1和b2是两个变量,变量里面存储的值都是变化的,所以在程序运行中JVM是无法判断里面具体的值 byte类型的变量在进行运算的时候,会自动类型提升为int类型 byte b4 = 3 + 4; 3和4都是常量,java有常量优化机制,就是在编译的的时候直接把3和4的结果赋值给b4了 long与float的取值范围谁大谁小 进行混合运算的时候,byte,short,char不会相互转换,都会自动类型提升为int类型,其他类型进行混合运算的是小的数据类型提升为大的 byte,short,char – int – long – float – double long: 8个字节 float：4个字节 IEEE754 4个字节是32个二进制位 1位是符号位 8位是指数位 00000000 11111111 0到255 1到254 -126到127 23位是尾数位 每个指数位减去127 A:它们底层的存储结构不同。 B:float表示的数据范围比long的范围要大 long：2^63-1 float：3.410^38 &gt; 210^38 &gt; 28^38 = 22^3^38 = 2*2^114 &gt; 2^63-1 字符和字符串参与运算 A:案例演示 System.out.println(‘a’); System.out.println(‘a’+1); 通过看结果知道’a’的值是多少,由此引出ASCII码表 B:ASCII码表的概述 记住三个值： ‘0’ 48 ‘A’ 65 ‘a’ 97 C:案例演示 System.out.println(“hello”+’a’+1); System.out.println(‘a’+1+”hello”); D:+在有字符串参与中被称为字符串连接符 System.out.println(“5+5=”+5+5); System.out.println(5+5+”=5+5”); char数据类型 A:char c = 97; 0到65535 B:Java语言中的字符char可以存储一个中文汉字吗?为什么呢? 可以。因为Java语言采用的是Unicode编码。Unicode编码中的每个字符占用两个字节。中文也是占的两个字节 所以，Java中的字符可以存储一个中文汉字 运算符算术运算符的基本用法 A:什么是运算符 就是对常量和变量进行操作的符号。 B:运算符的分类 算术运算符，赋值运算符，比较(关系或条件)运算符，逻辑运算符，位运算符，三目(元)运算符 C:算数运算符有哪些 +,-,*,/,%,++,– D:注意事项： a:+号在java中有三种作用,代表正号,做加法运算,字符串的连接符 b:整数相除只能得到整数。如果想得到小数，必须把数据变化为浮点数类型 c:/获取的是除法操作的商，%获取的是除法操作的余数 %运算符 当左边的绝对值小于右边绝对值时,结果是左边 当左边的绝对值等于右边或是右边的倍数时,结果是0 当左边的绝对值大于右边绝对值时,结果是余数 %运算符结果的符号只和左边有关系,与右边无关 任何一个正整数%2结果不是0就是1可以用来当作切换条件 算术运算符++和–的用法 A:++,–运算符的作用 自加（++）自减（–）运算 ++:自加。对原有的数据进行+1 –:自减。对原有的数据进行-1 B:案例演示 a:单独使用： 放在操作数的前面和后面效果一样。(这种用法是我们比较常见的) b:参与运算使用： 放在操作数的前面，先自增或者自减，然后再参与运算。 放在操作数的后面，先参与运算，再自增或者自减。 算术运算符++和–的练习 A:案例演示 请分别计算出a,b,c的值? 12345678int a = 10;int b = 10;int c = 10; a = b++; c = --a; b = ++a; a = c--; B:案例演示 请分别计算出x,y的值? 12int x = 4;int y = (x++)+(++x)+(x*10); C:面试题 byte b = 10; b++; b = b + 1; 问哪句会报错,为什么 赋值运算符的基本用法 A:赋值运算符有哪些 a:基本的赋值运算符：= 把=右边的数据赋值给左边。 b:扩展的赋值运算符：+=,-=,*=,/=,%= += 把左边和右边做加法，然后赋值给左边。 赋值运算符的面试题 A:案例演示 面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。 short s=1;s = s+1; short s=1;s+=1; 关系运算符的基本用法及其注意事项 A:关系运算符有哪些(比较运算符,条件运算符) ==,!=,&gt;,&gt;=,&lt;,&lt;= 注意事项： 无论你的操作是简单还是复杂，结果是boolean类型。 “==”不能写成”=”。 逻辑运算符的基本用法 A:逻辑运算符有哪些 &amp;,|,^,! &amp;&amp;,|| B:案例演示 逻辑运算符的基本用法 注意事项： a:逻辑运算符一般用于连接boolean类型的表达式或者值。 b:表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。 算术表达式：a + b 比较表达式：a == b(条件表达式) C:结论： &amp;逻辑与:有false则false。 |逻辑或:有true则true。 ^逻辑异或:相同为false，不同为true。 !逻辑非:非false则true，非true则false。 特点：偶数个不改变本身。 逻辑运算符&amp;&amp;和&amp;的区别 A:案例演示 &amp;&amp;和&amp;的区别? a:最终结果一样。 b:&amp;&amp;具有短路效果。左边是false，右边不执行。 &amp;是无论左边是false还是true,右边都会执行 B:同理||和|的区别?(学生自学) C:开发中常用谁? &amp;&amp;,||,! 位运算符的基本用法 A:位运算符有哪些 &amp;,|,^,~ ,&gt;&gt;,&gt;&gt;&gt;,&lt;&lt; B:案例演示 位运算符的基本用法1 &amp;,|,^,~ 的用法 &amp;:有0则0 |:有1则1 ^:相同则0，不同则1 ~:按位取反 位异或运算符的特点及面试题 A:案例演示 位异或运算符的特点 ^的特点：一个数据对另一个数据位异或两次，该数本身不变。 B:面试题： 请自己实现两个整数变量的交换 注意：以后讲课的过程中，我没有明确指定数据的类型，默认int类型。 位运算符的基本用法2及面试题 A:案例演示 &gt;&gt;,&gt;&gt;&gt;,&lt;&lt;的用法: &lt;&lt;:左移 左边最高位丢弃，右边补齐0 :右移 最高位是0，左边补齐0;最高为是1，左边补齐1 :无符号右移 无论最高位是0还是1，左边补齐0 最有效率的算出2 * 8的结果 三元运算符的基本用法 A:三元运算符的格式 (关系表达式) ? 表达式1 : 表达式2; B:三元运算符的执行流程 C:案例演示 获取两个数中的最大值 三元运算符的练习 A:案例演示 比较两个整数是否相同 B:案例演示 获取三个整数中的最大值 键盘录入键盘录入的基本格式讲解 A:为什么要使用键盘录入数据 a:为了让程序的数据更符合开发的数据 b:让程序更灵活一下 B:如何实现键盘录入呢? 先照格式来。 a:导包 格式： import java.util.Scanner; 位置： 在class上面。 b:创建键盘录入对象 格式： Scanner sc = new Scanner(System.in); c:通过对象获取数据 格式： int x = sc.nextInt(); C:案例演示 键盘录入1个整数，并输出到控制台。 键盘录入2个整数，并输出到控制台。 键盘录入的练习1 A:案例演示 键盘录入练习：键盘录入两个数据，并对这两个数据求和，输出其结果 B:案例演示 键盘录入练习：键盘录入两个数据，获取这两个数据中的最大值 键盘录入的练习2 A:案例演示 键盘录入练习：键盘录入两个数据，比较这两个数据是否相等 B:案例演示 键盘录入练习：键盘录入三个数据，获取这三个数据中的最大值 流程控制语句 A:什么是流程控制语句 流程控制语句：可以控制程序的执行流程。 B:流程控制语句的分类 顺序结构 选择结构 循环结构 C:执行流程： 从上往下，依次执行。 D:案例演示 输出几句话看效果即可 选择结构if语句格式1及其使用 A:选择结构的分类 if语句 switch语句 B:if语句有几种格式 格式1 格式2 格式3 C:if语句的格式1 123if(比较表达式) &#123; 语句体; &#125; D:执行流程： 先计算比较表达式的值，看其返回值是true还是false。 如果是true，就执行语句体； 如果是false，就不执行语句体； 选择结构if语句注意事项 A:案例演示 a:比较表达式无论简单还是复杂，结果必须是boolean类型 b:if语句控制的语句体如果是一条语句，大括号可以省略； 如果是多条语句，就不能省略。建议永远不要省略。 c:一般来说：有左大括号就没有分号，有分号就没有左大括号 选择结构if语句格式2及其使用 A:if语句的格式2 12345if(比较表达式) &#123; 语句体1;&#125;else &#123; 语句体2;&#125; B:执行流程： 首先计算比较表达式的值，看其返回值是true还是false。 如果是true，就执行语句体1； 如果是false，就执行语句体2； C:案例演示 a:获取两个数据中较大的值 b:判断一个数据是奇数还是偶数,并输出是奇数还是偶数 注意事项：else后面是没有比较表达式的，只有if后面有。 if语句的格式2和三元的相互转换问题 A:案例演示 if语句和三元运算符完成同一个效果 B:案例演示 if语句和三元运算符的区别 三元运算符实现的，都可以采用if语句实现。反之不成立。 什么时候if语句实现不能用三元改进呢? 当if语句控制的操作是一个输出语句的时候就不能。 为什么呢?因为三元运算符是一个运算符，运算符操作完毕就应该有一个结果，而不是一个输出。 选择结构if语句格式3及其使用 A:if语句的格式3： 1234567891011if(比较表达式1) &#123; 语句体1;&#125;else if(比较表达式2) &#123; 语句体2;&#125;else if(比较表达式3) &#123; 语句体3;&#125;...else &#123; 语句体n+1;&#125; B:执行流程： 首先计算比较表达式1看其返回值是true还是false， 如果是true，就执行语句体1，if语句结束。 如果是false，接着计算比较表达式2看其返回值是true还是false， 如果是true，就执行语句体2，if语句结束。 如果是false，接着计算比较表达式3看其返回值是true还是false， 如果都是false，就执行语句体n+1。 C:注意事项:最后一个else可以省略,但是建议不要省略,可以对范围外的错误值提示 选择结构if语句格式3练习 A:练习1 123456需求：键盘录入一个成绩，判断并输出成绩的等级。90-100 优80-89 良70-79 中60-69 及0-59 差 B:练习2 需求： 键盘录入x的值，计算出y的并输出。 x&gt;=3 y = 2 * x + 1; -1&lt;x&lt;3 y = 2 * x; x&lt;=-1 y = 2 * x - 1; 选择结构if语句的嵌套使用 A:案例演示 需求：获取三个数据中的最大值 if语句的嵌套使用。 选择结构switch语句的格式及其解释 A:switch语句的格式 123456789101112switch(表达式) &#123; case 值1： 语句体1; break; case 值2： 语句体2; break; … default： 语句体n+1; break; &#125; B:switch语句的格式解释 C:面试题 byte可以作为switch的表达式吗? long可以作为switch的表达式吗? String可以作为switch的表达式吗? C:执行流程 先计算表达式的值 然后和case后面的匹配，如果有就执行对应的语句，否则执行default控制的语句 选择结构switch语句的练习 A:整数(给定一个值,输出对应星期几) 选择结构switch语句的注意事项 A:案例演示 a:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 b:default可以省略吗? 可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。 特殊情况： case就可以把值固定。 A,B,C,D c:break可以省略吗? 最后一个可以省略,其他最好不要省略 会出现一个现象：case穿透。 最终我们建议不要省略 d:default一定要在最后吗? 不是，可以在任意位置。但是建议在最后。 e:switch语句的结束条件 a:遇到break就结束了 b:执行到switch的右大括号就结束了 选择结构switch语句练习 A:看程序写结果： 123456789101112int x = 2;int y = 3;switch(x)&#123; default: y++; break; case 3: y++; case 4: y++;&#125;System.out.println(\"y=\"+y); B:看程序写结果： 1234567891011int x = 2;int y = 3;switch(x)&#123; default: y++; case 3: y++; case 4: y++;&#125;System.out.println(\"y=\"+y); 选择结构if语句和switch语句的区别 A:总结switch语句和if语句的各自使用场景 switch建议判断固定值的时候用 if建议判断区间或范围的时候用 B:案例演示 分别用switch语句和if语句实现下列需求： 键盘录入月份，输出对应的季节 循环结构概述 A:循环结构的分类 for,while,do…while for语句的格式及其使用 B:循环结构for语句的格式： 123for(初始化表达式;条件表达式;循环后的操作表达式) &#123; 循环体;&#125; C执行流程： a:执行初始化语句 b:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 c:执行循环体语句; d:执行循环后的操作表达式 e:回到B继续。 D:案例演示 在控制台输出10次”helloworld” for语句的练习之获取数据 A:案例演示 需求：请在控制台输出数据1-10 需求：请在控制台输出数据10-1 B:注意事项 a:判断条件语句无论简单还是复杂结果是boolean类型。 b:循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。 c:一般来说：有左大括号就没有分号，有分号就没有左大括号 for语句的练习之求和思想 A:案例演示 需求：求出1-10之间数据之和 B:学生练习 需求：求出1-100之间偶数和 需求：求出1-100之间奇数和 for语句的练习之水仙花 A:案例演示 需求：在控制台输出所有的”水仙花数” 所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。 举例：153就是一个水仙花数。 153 = 111 + 555 + 333 = 1 + 125 + 27 = 153 for语句的练习之统计思想 A:案例演示 需求：统计”水仙花数”共有多少个 while语句的格式和基本使用 A:循环结构while语句的格式： 123456789101112while循环的基本格式：while(判断条件语句) &#123; 循环体语句;&#125;完整格式：初始化语句; while(判断条件语句) &#123; 循环体语句; 控制条件语句;&#125; B:执行流程： a:执行初始化语句 b:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 c:执行循环体语句; d:执行控制条件语句 e:回到B继续。 C:案例演示 需求：请在控制台输出数据1-10 while语句的练习 A:求和思想 求1-100之和 B:统计思想 统计”水仙花数”共有多少个 do…while语句的格式和基本使用 A:循环结构do…while语句的格式： 12345678910do &#123; 循环体语句;&#125;while(判断条件语句);完整格式；初始化语句;do &#123; 循环体语句; 控制条件语句;&#125;while(判断条件语句); B:执行流程： a:执行初始化语句 b:执行循环体语句; c:执行控制条件语句 d:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 e:回到b继续。 C:案例演示 需求：请在控制台输出数据1-10 三种循环语句的区别 A:案例演示 三种循环语句的区别: do…while循环至少执行一次循环体。 而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。 B:案例演示 for循环和while循环的区别： A:如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用谁就用for循环。因为变量及早的从内存中消失，可以提高内存的使用效率。 注意事项之死循环 A:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。 B:两种最简单的死循环格式 while(true){…} for(;;){…} 循环嵌套输出4行5列的星星 A:案例演示 需求：请输出一个4行5列的星星(*)图案。 如图： ***** ***** ***** ***** 注意： System.out.println(&quot;*&quot;);和System.out.print(&quot;*&quot;);的区别 B:结论： 外循环控制行数，内循环控制列数 循环嵌套输出正三角形 A:案例演示 需求：请输出下列的形状 * ** *** **** ***** 九九乘法表 A:案例演示 需求：在控制台输出九九乘法表。 B:代码优化 注意： &apos;\\x&apos; x表示任意，\\是转义符号,这种做法叫转移字符。 &apos;\\t&apos; tab键的位置 &apos;\\r&apos; 回车 &apos;\\n&apos; 换行 &apos;\\&quot;&apos; &apos;\\&apos;&apos; 控制跳转语句break语句 A:break的使用场景 只能在switch和循环中 控制跳转语句continue语句 A:continue的使用场景 只能在循环中 控制跳转语句标号 标号:标记某个循环对其控制 标号组成规则:其实就是合法的标识符 控制调整语句练习 A:练习题 12345678910for(int x=1; x&lt;=10; x++) &#123; if(x%3==0) &#123; //在此处填写代码 &#125; System.out.println(“Java基础班”);&#125;我想在控制台输出2次:“Java基础班“我想在控制台输出7次:“Java基础班“我想在控制台输出13次:“Java基础班“ 控制跳转语句return语句 A:return的作用 返回 其实它的作用不是结束循环的，而是结束方法的。 B:案例演示 return和break以及continue的区别? return是结束方法 break是跳出循环 continue是终止本次循环继续下次循环 方法方法概述和格式说明 A:为什么要有方法 提高代码的复用性 B:什么是方法 完成特定功能的代码块。 C:方法的格式 1234修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) &#123; 方法体语句; return 返回值; &#125; D:方法的格式说明 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 返回值类型：就是功能结果的数据类型。 方法名：符合命名规则即可。方便我们的调用。 参数： 实际参数：就是实际参与运算的。 形式参数；就是方法定义上的，用于接收实际参数的。 参数类型：就是参数的数据类型 参数名：就是变量名 方法体语句：就是完成功能的代码。 return：结束方法的。 返回值：就是功能的结果，由return带给调用者。 方法之求和案例及其调用 A:如何写一个方法 1,明确返回值类型 2,明确参数列表 B:案例演示 需求：求两个数据之和的案例 C:方法调用图解 方法的注意事项 A:方法调用(有具体返回值) a:单独调用,一般来说没有意义，所以不推荐。 b:输出调用,但是不够好。因为我们可能需要针对结果进行进一步的操作。 c:赋值调用,推荐方案。 B:案例演示 a:方法不调用不执行 b:方法与方法是平级关系，不能嵌套定义 c:方法定义的时候参数之间用逗号隔开 d:方法调用的时候不用在传递数据类型 e:如果方法有明确的返回值，一定要有return带回一个值 方法的练习 A:案例演示 需求：键盘录入两个数据，返回两个数中的较大值 B:案例演示 需求：键盘录入两个数据，比较两个数是否相等 方法之输出星形及其调用 A:案例演示 需求：根据键盘录入的行数和列数，在控制台输出星形 B:方法调用：(无返回值,void) 单独调用 输出调用(错误) 赋值调用(错误) 方法的练习2 A:案例演示 需求：根据键盘录入的数据输出对应的乘法表 方法重载概述和基本使用 A:方法重载概述 求和案例 2个整数 3个整数 4个整数 B:方法重载： 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 参数列表不同： A:参数个数不同 B:参数类型不同 C:参数的顺序不同(算重载,但是在开发中不用) 方法重载练习比较数据是否相等 A:案例演示 需求：比较两个数据是否相等。 参数类型分别为两个int类型，两个double类型，并在main方法中进行测试 数组数组概述和定义格式说明 A:为什么要有数组(容器) 为了存储同种数据类型的多个值 B:数组概念 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。 数组既可以存储基本数据类型，也可以存储引用数据类型。 C:数组定义格式 数据类型[] 数组名 = new 数据类型[数组的长度]; 数组的初始化动态初始化 A:什么是数组的初始化 就是为数组开辟连续的内存空间，并为每个数组元素赋予值 B:如何对数组进行初始化 a:动态初始化 只指定长度，由系统给出初始化值 int[] arr = new int[5]; b:静态初始化 给出初始化值，由系统决定长度 C:动态初始化的格式： 数据类型[] 数组名 = new 数据类型[数组长度]; D:案例演示 输出数组名称和数组元素 Java中的内存分配以及栈和堆的区别 A:栈(掌握) 存储局部变量 B:堆(掌握) 存储new出来的数组或对象 C:方法区 面向对象部分讲解 D:本地方法区 和系统相关 E:寄存器 给CPU使用数组的内存图解1一个数组 A:画图演示 一个数组 数组的内存图解2二个数组 A:画图演示 二个不同的数组 数组的内存图解3三个引用两个数组 A:画图演示 三个引用，有两个数组的引用指向同一个地址 数组的初始化静态初始化及内存图 A:静态初始化的格式： 格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…}; 简化格式： 数据类型[] 数组名 = {元素1,元素2,…}; B:案例演示 对数组的解释 输出数组名称和数组元素 C:画图演示 一个数组 数组操作的两个常见小问题越界和空指针 A:案例演示 a:ArrayIndexOutOfBoundsException:数组索引越界异常 原因：你访问了不存在的索引。 b:NullPointerException:空指针异常 原因：数组已经不在指向堆内存了。而你还用数组名去访问元素。 int[] arr = {1,2,3}; arr = null; System.out.println(arr[0]); 数组的操作1遍历 A:案例演示 数组遍历：就是依次输出数组中的每一个元素。 数组的属性:arr.length数组的长度 数组的最大索引:arr.length - 1; 12345public static void print(int[] arr) &#123; for (int i = 0;i &lt; arr.length ;i++ ) &#123; System.out.print(arr[i] + \" \"); &#125;&#125; 数组的操作2获取最值 A:案例演示 数组获取最值(获取数组中的最大值最小值) 12345678910public static int getMax(int[] arr) &#123; int max = arr[0]; for (int i = 1;i &lt; arr.length ;i++ ) &#123; //从数组的第二个元素开始遍历 if (max &lt; arr[i]) &#123; //如果max记录的值小于的数组中的元素 max = arr[i]; //max记录住较大的 &#125; &#125; return max;&#125; 数组的操作3反转 A:案例演示 数组元素反转(就是把元素对调) 123456789101112public static void reverseArray(int[] arr) &#123; for (int i = 0;i &lt; arr.length / 2 ; i++) &#123; //arr[0]和arr[arr.length-1-0]交换 //arr[1]和arr[arr.length-1-1]交换 //arr[2]和arr[arr.lentth-1-2] //... int temp = arr[i]; arr[i] = arr[arr.length-1-i]; arr[arr.length-1-i] = temp; &#125;&#125; 数组的操作4查表法 A:案例演示 数组查表法(根据键盘录入索引,查找对应星期) 1234public static char getWeek(int week) &#123; char[] arr = &#123;' ','一','二','三','四','五','六','日'&#125;; //定义了一张星期表 return arr[week]; //通过索引获取表中的元素&#125; 数组的操作5基本查找 A:案例演示 数组元素查找(查找指定元素第一次在数组中出现的索引) 12345678public static int getIndex(int[] arr,int value) &#123; for (int i = 0;i &lt; arr.length ;i++ ) &#123; //数组的遍历 if (arr[i] == value) &#123; //如果数组中的元素与查找的元素匹配 return i; &#125; &#125; return -1;&#125; 二维数组概述和格式1的讲解 A:二维数组概述 B:二维数组格式1 int[][] arr = new int[3][2]; C:二维数组格式1的解释 D:注意事项 a:以下格式也可以表示二维数组 1:数据类型 数组名[][] = new 数据类型[m][n]; 2:数据类型[] 数组名[] = new 数据类型[m][n]; B:注意下面定义的区别 int x; int y; int x,y; int[] x; int[] y[]; int[] x,y[]; x是一维数组,y是二维数组 E:案例演示 定义二维数组，输出二维数组名称，一维数组名称，一个元素 二维数组格式1的内存图解 A:画图演示 画图讲解上面的二维数组名称，一维数组名称，一个元素的值的问题 二维数组格式2的讲解及其内存图解 A:二维数组格式2 int[][] arr = new int[3][]; B:二维数组格式2的解释 C:案例演示 讲解格式，输出数据，并画内存图 二维数组格式3的讲解及其内存图解 A:二维数组格式3 int[][] arr = {{1,2,3},{4,5},{6,7,8,9}}; B:二维数组格式3的解释 C:案例演示 讲解格式，输出数据，并画内存图 二维数组练习1遍历 A:案例演示 需求：二维数组遍历 外循环控制的是二维数组的长度，其实就是一维数组的个数。 内循环控制的是一维数组的长度。 123456789int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8,9&#125;&#125;; for (int i = 0;i &lt; arr.length ;i++ ) &#123; //获取到每个二维数组中的一维数组 for (int j = 0;j &lt; arr[i].length ;j++ ) &#123; //获取每个一维数组中的元素 System.out.print(arr[i][j] + \" \"); &#125; System.out.println();&#125; 二维数组练习2求和 A:案例演示 需求：公司年销售额求和 某公司按照季度和月份统计的数据如下：单位(万元) 第一季度：22,66,44 第二季度：77,33,88 第三季度：25,45,65 第四季度：11,66,99 12345678910int[][] arr = &#123;&#123;22,66,44&#125;,&#123;77,33,88&#125;,&#123;25,45,65&#125;,&#123;11,66,99&#125;&#125;;int sum = 0; //定义变量,记录每次相加的结果for (int i = 0;i &lt; arr.length ;i++ ) &#123; //获取每一个一维数组 for (int j = 0;j &lt; arr[i].length ;j++ ) &#123; //获取每一个一维数组中的元素 sum = sum + arr[i][j]; //累加 &#125;&#125;System.out.println(sum); 思考题Java中的参数传递问题及图解 A:案例演示 看程序写结果，并画内存图解释 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println(\"a:\"+a+\",b:\"+b); change(a,b); System.out.println(\"a:\"+a+\",b:\"+b); int[] arr = &#123;1,2,3,4,5&#125;; change(arr); System.out.println(arr[1]);&#125; public static void change(int a,int b) &#123; System.out.println(\"a:\"+a+\",b:\"+b); a = b; b = a + b; System.out.println(\"a:\"+a+\",b:\"+b);&#125; public static void change(int[] arr) &#123; for(int x=0; x&lt;arr.length; x++) &#123; if(arr[x]%2==0) &#123; arr[x]*=2; &#125; &#125;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"http://www.aiwyt.com/tags/编程/"},{"name":"java","slug":"java","permalink":"http://www.aiwyt.com/tags/java/"}]},{"title":"程序猿常用网站推荐","date":"2017-03-27T07:09:21.000Z","path":"/uncategorized/程序猿常用网站推荐.html","text":"","tags":[]},{"title":"Mac下好用的应用集合","date":"2017-03-27T07:07:20.000Z","path":"/uncategorized/Mac下好用的应用集合.html","text":"","tags":[]},{"title":"Markdown基础应用","date":"2017-03-27T07:05:38.000Z","path":"/uncategorized/Markdown基础应用.html","text":"","tags":[]},{"title":"使用hexo搭建GitHub博客","date":"2017-03-27T03:26:59.000Z","path":"/uncategorized/使用hexo搭建GitHub博客.html","text":"最近在学习Java开发，开始的时候使用有道云笔记，记了些笔记希望可以分享给其他人，觉得有道云笔记分享比较麻烦，只能单篇的分享出去。就想找一个博客平台在上面写，看了csdn，博客园，简书等，发现都不能合自己心意。就准备自己搭建一个博客，之后根据自己的喜好自定义，完善。下面就是我搭建博客的过程： 本文主要讲解，如何使用GitHub+Hexo搭建个人博客，因本人使用的是MacBook Air 所以，该文章是基于苹果的Mac osx操作系统，windows操作系统搭建方法大同小异。 Github准备注册GitHub账号注册GitHub账号这里我们就不多说了，大家可以直接进入GitHub官网注册。 创建仓库登录账号后，在Github页面右上方选择New repository创建一个新的仓库。 (图片来自简书) (图片来自简书) 在Repository name输入框中 输入： 你的github名字.github.io 然后点击Create repository即可 生成秘钥 在终端（Terminal)输入： ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 一直Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入https://github.com/settings/ssh： (图片来自简书)将复制的内容粘贴到Key的输入框，随便写好Title里面的内容，点击Add SSH key按钮即可。## 安装node.js点击进入node.js官网(图片来自node.js官网) 目前node.js有两个推荐版本，分为通用版和最新版，本文使用v.7.7.4版本，点击可直接进行下载。下载安装即可。 安装完成后，进入终端（Terminal)输入： npm -v node -v 如下图显示版本号，安装成功。 安装Git因Mac 安装Xcode后就会安装有Git，这里就不多说。如果您的电脑没有安装Git，可前往Git官网下载安装即可。 (图片来自简书) 安装配置hexo (图片来自简书)接下来我们的操作都将在Terminal终端进行： 定位博客本地放置的路径1$ cd 文件夹注：这个文件夹，最好不要选择需要管理员权限才能创建的文件夹 下载安装Hexo1$ npm install -g hexo-cli安装好hexo后，继续在终端输入：1$ hexo若出现如下图，则说明安装成功:(图片来自简书) 初始化博客 123456&lt;!-- 建立一个博客文件夹，并初始化博客，&lt;folder&gt;为文件夹的名称，可以随便起名字 --&gt;$ hexo init &lt;folder&gt; // 进入博客文件夹，&lt;folder&gt;为文件夹的名称$ cd &lt;folder&gt;// node.js的命令，根据博客既定的dependencies配置安装所有的依赖包$ npm install 初始化博客以后，我们可以看到博客文件夹里的文件是这样的： 配置博客 基于上一步，我们对博客修改相应的配置，我们用到_config.yml文件，下面是该文件的默认参数信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: # The title of your websitesubtitle: # The subtitle of your websitedescription: # The description of your websiteauthor: # Your namelanguage: # The language of your websitetimezone: # URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.com/childroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 这些配置中，很多是不需要我们去修改设置的，我们只要修改下面的几个配置接可以了： 修改网站相关信息 123456title: inerdstacksubtitle: the stack of it nerdsdescription: start from zeroauthor: inerdstacklanguage: zh-CNtimezone: Asia/Shanghai language和timezone都是有输入规范的，详细可参考语言规范和时区规范。 注意：每一项的填写，其:后面都要保留一个空格，下同。 个人域名1url: http://aiwyt.com 对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。 配置部署1234deploy: type: git repo: https://github.com/false7518/false7518.github.io branch: master 其中repo项是之前Github上创建好的仓库的地址，可以通过如下图所示的方式得到： Branch是项目的分支，我们默认用主分支master。 发表一篇文章在终端输入： 12// 新建一篇文章hexo new &quot;文章标题&quot; 我们可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件用Markdown编辑器打开文件，我们可以看到这样的内容：我们写下: 123&gt;最近在学习Java开发，开始的时候使用有道云笔记，记了些笔记希望可以分享给其他人，觉得有道云笔记分享比较麻烦，只能单篇的分享出去。&gt;就想找一个博客平台在上面写，看了csdn，博客园，简书等，发现都不能合自己心意。&gt;就准备自己搭建一个博客，之后根据自己的喜好自定义，完善。下面就是我搭建博客的过程： 保存后，我们进行本地发布： 123$ hexo clean$ hexo g$ hexo server 如下图：发布成功,这个时候我们打开浏览器，输入： 1http://localhost:4000/ 我们可以在浏览器端看到我们搭建好的博客和发布的文章：因为我这里使用了yilia主题，所以界面风格可能和大家的有所不同。如何更换主题，本文之后会详细介绍。 到了这里发布博客就已经完成了。但是毕竟我们目前发布的只有本机看得到，怎么让其他人看到我们写的博客呢？这时候我们来看看博客的部署。 我们只要在终端执行这样的命令即可： 12345$ hexo generate$ hexo deploy 或者可以简写为$ hexo d g 这样我们在浏览器中输入刚才我们创建的仓库对应的链接，例如： 1https://false7518.github.io 就可以在任何地方访问到我们的博客了。 主题更换 下载主题 1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 配置 首先我们切换到我们刚才创建的博客的目录下，这个文件夹主要用来进行博客的管理，看下目录下的详情。 yilia主题就在themes目录下了,_config.yml主要是主目录下的一些配置，很清晰，每个地方应该如何填写也很简单 修改hexo根目录下的 _config.yml ： theme: yilia 更新 12cd themes/yiliagit pull 主题配置文件在主题主目录下的_config.yml，请根据自己需要修改使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# Headermenu: 主页: / 随笔: /tags/随笔/# SubNavsubnav: github: &quot;#&quot; weibo: &quot;#&quot; rss: &quot;#&quot; zhihu: &quot;#&quot; #qq: &quot;#&quot; #weixin: &quot;#&quot; #jianshu: &quot;#&quot; #douban: &quot;#&quot; #segmentfault: &quot;#&quot; #bilibili: &quot;#&quot; #acfun: &quot;#&quot; #mail: &quot;mailto:litten225@qq.com&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: # Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: &apos;展开全文&apos;# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 请在需要打赏的文章的md文件头部，设置属性reward: true# 打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: &apos;谢谢你请我吃糖果&apos;# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # Miscellaneousbaidu_analytics: &apos;&apos;google_analytics: &apos;&apos;favicon: /favicon.png#你的头像urlavatar:#是否开启分享share_jia: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: false# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: &apos;#4d4d4d&apos; # 右滑板块背景 slider: &apos;linear-gradient(200deg,#a0cfe4,#e8c37e)&apos;# slider的设置slider: # 是否默认展开tags板块 showTags: false # 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: &apos;所有文章&apos; friends: &apos;友链&apos; aboutme: &apos;关于我&apos;friends: 友情链接1: http://localhost:4000/ 友情链接2: http://localhost:4000/ 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/aboutme: 很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家 配置之后重新发布，我们的博客主题就会替换成yilia主题了。替换其他主题的方法也是相同的，这里就不多说。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.aiwyt.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://www.aiwyt.com/tags/博客/"},{"name":"Github","slug":"Github","permalink":"http://www.aiwyt.com/tags/Github/"},{"name":"yilia","slug":"yilia","permalink":"http://www.aiwyt.com/tags/yilia/"}]},{"title":"Hello World","date":"2017-03-27T01:32:20.000Z","path":"/uncategorized/hello-world.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]